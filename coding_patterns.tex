\documentclass[10pt, a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}

\geometry{a4paper, margin=1in}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{pythonstyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=pythonstyle}

\title{100 LeetCode Hard Problems Study Guide}
\author{}
\date{}

\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Median of Two Sorted Arrays}
\subsection*{Problem Description}
Find the median of two sorted arrays with overall runtime complexity of $O(\log(m+n))$.

\subsection*{Solution Approach}
\begin{itemize}
    \item Use binary search on the smaller array.
    \item Find partition points in both arrays.
    \item Ensure elements on left $\le$ elements on right.
    \item Calculate median based on total length (odd/even).
\end{itemize}

\subsection*{Key Algorithms}
Binary Search, Partitioning

\subsection*{Edge Cases}
Empty arrays, single element arrays, all elements in one array < other array.

\begin{lstlisting}[language=Python]
from typing import List

def findMedianSortedArrays(nums1: List[int], nums2: List[int]) -> float:
    # Ensure nums1 is the smaller array for optimization
    if len(nums1) > len(nums2):
        nums1, nums2 = nums2, nums1
    
    m, n = len(nums1), len(nums2)
    low, high = 0, m
    
    while low <= high:
        # Partition nums1 at i and nums2 at j
        i = (low + high) // 2
        j = (m + n + 1) // 2 - i
        
        # Handle edge values with infinity
        left1 = float('-inf') if i == 0 else nums1[i - 1]
        right1 = float('inf') if i == m else nums1[i]
        left2 = float('-inf') if j == 0 else nums2[j - 1]
        right2 = float('inf') if j == n else nums2[j]
        
        # Check if partition is correct
        if left1 <= right2 and left2 <= right1:
            # Found correct partition
            if (m + n) % 2 == 0:
                return (max(left1, left2) + min(right1, right2)) / 2
            else:
                return max(left1, left2)
        elif left1 > right2:
            # Move left in nums1
            high = i - 1
        else:
            # Move right in nums1
            low = i + 1
    
    return 0.0
\end{lstlisting}
\textbf{Complexity:} Time $O(\log(\min(m,n)))$, Space $O(1)$

\section{Regular Expression Matching}
\subsection*{Problem Description}
Implement regex matching with `.` (any single char) and `*` (zero or more of preceding element).

\subsection*{Solution Approach}
\begin{itemize}
    \item Use dynamic programming with 2D table.
    \item \texttt{dp[i][j] = true} if \texttt{s[0:i]} matches \texttt{p[0:j]}.
    \item Handle `*` by checking zero occurrences or multiple occurrences.
    \item Build solution bottom-up.
\end{itemize}

\subsection*{Key Algorithms}
Dynamic Programming

\subsection*{Edge Cases}
Empty pattern/string, consecutive `*`, `.*` matching everything.

\begin{lstlisting}[language=Python]
def isMatch(s: str, p: str) -> bool:
    m, n = len(s), len(p)
    # dp[i][j] means s[0:i] matches p[0:j]
    dp = [[False] * (n + 1) for _ in range(m + 1)]
    
    # Empty string matches empty pattern
    dp[0][0] = True
    
    # Handle patterns like a*, a*b*, etc. that can match empty string
    for j in range(2, n + 1):
        if p[j - 1] == '*':
            dp[0][j] = dp[0][j - 2]
    
    # Fill the dp table
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if p[j - 1] == '*':
                # Check zero occurrences of preceding element
                dp[i][j] = dp[i][j - 2]
                # Check one or more occurrences
                if p[j - 2] == s[i - 1] or p[j - 2] == '.':
                    dp[i][j] = dp[i][j] or dp[i - 1][j]
            else:
                # Regular character match or '.'
                if p[j - 1] == s[i - 1] or p[j - 1] == '.':
                    dp[i][j] = dp[i - 1][j - 1]
    
    return dp[m][n]
\end{lstlisting}
\textbf{Complexity:} Time $O(mn)$, Space $O(mn)$

\section{Merge k Sorted Lists}
\subsection*{Problem Description}
Merge k sorted linked lists into one sorted list.

\subsection*{Solution Approach}
\begin{itemize}
    \item Use min-heap to track smallest elements.
    \item Push first element of each list to heap.
    \item Pop minimum, add to result, push next from same list.
    \item Continue until heap is empty.
\end{itemize}

\subsection*{Key Algorithms}
Min-Heap, Priority Queue

\subsection*{Edge Cases}
Empty lists, single list, all `None` lists.

\begin{lstlisting}[language=Python]
from typing import List, Optional
import heapq

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeKLists(lists: List[Optional[ListNode]]) -> Optional[ListNode]:
    # Min heap to store (value, list_index, node)
    heap = []
    
    # Add first node of each list to heap
    for i, node in enumerate(lists):
        if node:
            heapq.heappush(heap, (node.val, i, node))
    
    # Dummy head for result
    dummy = ListNode(0)
    current = dummy
    
    while heap:
        # Get minimum element
        val, list_idx, node = heapq.heappop(heap)
        
        # Add to result
        current.next = node
        current = current.next
        
        # Add next node from same list if exists
        if node.next:
            heapq.heappush(heap, (node.next.val, list_idx, node.next))
    
    return dummy.next
\end{lstlisting}
\textbf{Complexity:} Time $O(N \log k)$ where N = total nodes, Space $O(k)$

\section{Reverse Nodes in k-Group}
\subsection*{Problem Description}
Reverse nodes of linked list in groups of k.

\subsection*{Solution Approach}
\begin{itemize}
    \item Count nodes to ensure enough for reversal.
    \item Reverse k nodes at a time.
    \item Connect reversed groups properly.
    \item Handle remaining nodes (don't reverse if < k).
\end{itemize}

\subsection*{Key Algorithms}
Linked List Manipulation, Reversal

\subsection*{Edge Cases}
k = 1, k > list length, exact multiple of k nodes.

\begin{lstlisting}[language=Python]
def reverseKGroup(head: Optional[ListNode], k: int) -> Optional[ListNode]:
    # Count total nodes
    count = 0
    node = head
    while node:
        count += 1
        node = node.next
    
    # Dummy node to simplify edge cases
    dummy = ListNode(0)
    dummy.next = head
    prev_group = dummy
    
    while count >= k:
        # Current group starts after prev_group
        current = prev_group.next
        next_node = current.next
        
        # Reverse k nodes
        for _ in range(k - 1):
            current.next = next_node.next
            next_node.next = prev_group.next
            prev_group.next = next_node
            next_node = current.next
        
        # Move to next group
        prev_group = current
        count -= k
    
    return dummy.next
\end{lstlisting}
\textbf{Complexity:} Time $O(n)$, Space $O(1)$

\section{Substring with Concatenation of All Words}
\subsection*{Problem Description}
Find all starting indices of substring(s) that is a concatenation of all words exactly once.

\subsection*{Solution Approach}
\begin{itemize}
    \item Use sliding window with hashmap.
    \item Window size = \texttt{len(words) * len(words[0])}.
    \item Check each possible starting position.
    \item Verify word counts match expected.
\end{itemize}

\subsection*{Key Algorithms}
Sliding Window, Hash Map

\subsection*{Edge Cases}
Duplicate words, overlapping results, single word.

\begin{lstlisting}[language=Python]
from typing import List
from collections import defaultdict

def findSubstring(s: str, words: List[str]) -> List[int]:
    if not s or not words:
        return []
    
    word_len = len(words[0])
    total_len = word_len * len(words)
    word_count = defaultdict(int)
    
    # Count frequency of each word
    for word in words:
        word_count[word] += 1
    
    result = []
    
    # Try each possible starting position
    for i in range(len(s) - total_len + 1):
        seen = defaultdict(int)
        j = 0
        
        # Check if substring starting at i is valid
        while j < len(words):
            word = s[i + j * word_len : i + (j + 1) * word_len]
            
            if word not in word_count:
                break
                
            seen[word] += 1
            
            if seen[word] > word_count[word]:
                break
                
            j += 1
        
        # All words matched
        if j == len(words):
            result.append(i)
    
    return result
\end{lstlisting}
\textbf{Complexity:} Time $O(n \cdot m \cdot w)$ where n = len(s), m = len(words), w = word length, Space $O(m)$

\section{Longest Valid Parentheses}
\subsection*{Problem Description}
Find length of longest valid parentheses substring.

\subsection*{Solution Approach}
\begin{itemize}
    \item Use stack to track indices.
    \item Push -1 initially as base.
    \item For `(`: push index.
    \item For `)`: pop and calculate length using current index - top of stack.
\end{itemize}

\subsection*{Key Algorithms}
Stack

\subsection*{Edge Cases}
All open/close parentheses, empty string, nested parentheses.

\begin{lstlisting}[language=Python]
def longestValidParentheses(s: str) -> int:
    max_length = 0
    stack = [-1]  # Base for length calculation
    
    for i, char in enumerate(s):
        if char == '(':
            stack.append(i)
        else:  # char == ')'
            stack.pop()
            
            if not stack:
                # No matching '(' for this ')'
                stack.append(i)
            else:
                # Calculate length of valid substring
                max_length = max(max_length, i - stack[-1])
    
    return max_length
\end{lstlisting}
\textbf{Complexity:} Time $O(n)$, Space $O(n)$

\section{Sudoku Solver}
\subsection*{Problem Description}
Solve a 9x9 Sudoku puzzle by filling empty cells.

\subsection*{Solution Approach}
\begin{itemize}
    \item Use backtracking.
    \item For each empty cell, try digits 1-9.
    \item Check if placement is valid (row, column, 3x3 box).
    \item Recursively solve remaining board.
    \item Backtrack if no solution found.
\end{itemize}

\subsection*{Key Algorithms}
Backtracking, Constraint Satisfaction

\subsection*{Edge Cases}
Invalid initial board, multiple solutions (return any).

\begin{lstlisting}[language=Python]
def solveSudoku(board: List[List[str]]) -> None:
    def is_valid(row: int, col: int, num: str) -> bool:
        # Check row
        for j in range(9):
            if board[row][j] == num:
                return False
        
        # Check column
        for i in range(9):
            if board[i][col] == num:
                return False
        
        # Check 3x3 box
        box_row, box_col = 3 * (row // 3), 3 * (col // 3)
        for i in range(box_row, box_row + 3):
            for j in range(box_col, box_col + 3):
                if board[i][j] == num:
                    return False
        
        return True
    
    def solve() -> bool:
        # Find empty cell
        for i in range(9):
            for j in range(9):
                if board[i][j] == '.':
                    # Try digits 1-9
                    for num in '123456789':
                        if is_valid(i, j, num):
                            board[i][j] = num
                            
                            if solve():
                                return True
                            
                            # Backtrack
                            board[i][j] = '.'
                    
                    return False
        
        # All cells filled
        return True
    
    solve()
\end{lstlisting}
\textbf{Complexity:} Time $O(9^m)$ where m = empty cells, Space $O(1)$

\section{First Missing Positive}
\subsection*{Problem Description}
Find the smallest missing positive integer in $O(n)$ time and $O(1)$ space.

\subsection*{Solution Approach}
\begin{itemize}
    \item Place each number in its correct position (\texttt{nums[i] = i+1}).
    \item Swap elements to their correct positions.
    \item Find first position where \texttt{nums[i] != i+1}.
    \item Handle numbers outside range [1, n].
\end{itemize}

\subsection*{Key Algorithms}
Array Manipulation, Cyclic Sort

\subsection*{Edge Cases}
All negative, all > n, duplicates, [1,2,3,...,n].

\begin{lstlisting}[language=Python]
def firstMissingPositive(nums: List[int]) -> int:
    n = len(nums)
    
    # Place each positive integer at its correct position
    for i in range(n):
        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
            # Swap to correct position
            correct_pos = nums[i] - 1
            nums[i], nums[correct_pos] = nums[correct_pos], nums[i]
    
    # Find first missing positive
    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
    
    # All positions filled correctly, answer is n + 1
    return n + 1
\end{lstlisting}
\textbf{Complexity:} Time $O(n)$, Space $O(1)$

\section{Trapping Rain Water}
\subsection*{Problem Description}
Calculate water trapped after raining given elevation map.

\subsection*{Solution Approach}
\begin{itemize}
    \item Use two pointers from both ends.
    \item Track max height seen from left and right.
    \item Water trapped = \texttt{min(left\_max, right\_max) - current height}.
    \item Move pointer with smaller max inward.
\end{itemize}

\subsection*{Key Algorithms}
Two Pointers

\subsection*{Edge Cases}
Monotonic array, no water trapped, single peak.

\begin{lstlisting}[language=Python]
def trap(height: List[int]) -> int:
    if not height:
        return 0
    
    left, right = 0, len(height) - 1
    left_max = right_max = 0
    water = 0
    
    while left < right:
        if height[left] < height[right]:
            # Process left side
            if height[left] >= left_max:
                left_max = height[left]
            else:
                water += left_max - height[left]
            left += 1
        else:
            # Process right side
            if height[right] >= right_max:
                right_max = height[right]
            else:
                water += right_max - height[right]
            right -= 1
    
    return water
\end{lstlisting}
\textbf{Complexity:} Time $O(n)$, Space $O(1)$

\section{Wildcard Matching}
\subsection*{Problem Description}
Implement wildcard pattern matching with `?` (any single char) and `*` (any sequence).

\subsection*{Solution Approach}
\begin{itemize}
    \item Use dynamic programming.
    \item \texttt{dp[i][j] = true} if \texttt{s[0:i]} matches \texttt{p[0:j]}.
    \item `*` can match empty or any sequence.
    \item `?` matches exactly one character.
\end{itemize}

\subsection*{Key Algorithms}
Dynamic Programming

\subsection*{Edge Cases}
Multiple `*`, leading/trailing `*`, empty pattern/string.

\begin{lstlisting}[language=Python]
def isMatch(s: str, p: str) -> bool:
    m, n = len(s), len(p)
    dp = [[False] * (n + 1) for _ in range(m + 1)]
    
    # Empty pattern matches empty string
    dp[0][0] = True
    
    # Handle patterns with leading '*'
    for j in range(1, n + 1):
        if p[j - 1] == '*':
            dp[0][j] = dp[0][j - 1]
    
    # Fill dp table
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if p[j - 1] == '*':
                # '*' matches empty or any sequence
                dp[i][j] = dp[i - 1][j] or dp[i][j - 1]
            elif p[j - 1] == '?' or p[j - 1] == s[i - 1]:
                # Character match or '?'
                dp[i][j] = dp[i - 1][j - 1]
    
    return dp[m][n]
\end{lstlisting}
\textbf{Complexity:} Time $O(mn)$, Space $O(mn)$

\section{N-Queens}
\subsection*{Problem Description}
Place N queens on NxN board so no two queens attack each other.

\subsection*{Solution Approach}
\begin{itemize}
    \item Use backtracking with row-by-row placement.
    \item Track columns, diagonals, anti-diagonals under attack.
    \item Try each column in current row.
    \item Recursively solve for next row.
\end{itemize}

\subsection*{Key Algorithms}
Backtracking

\subsection*{Edge Cases}
N = 1, N = 2,3 (no solution).

\begin{lstlisting}[language=Python]
def solveNQueens(n: int) -> List[List[str]]:
    result = []
    board = [['.'] * n for _ in range(n)]
    cols = set()
    diags = set()  # row - col
    anti_diags = set()  # row + col
    
    def backtrack(row: int) -> None:
        if row == n:
            # Found valid solution
            result.append([''.join(row) for row in board])
            return
        
        for col in range(n):
            if col in cols or (row - col) in diags or (row + col) in anti_diags:
                continue
            
            # Place queen
            board[row][col] = 'Q'
            cols.add(col)
            diags.add(row - col)
            anti_diags.add(row + col)
            
            # Try next row
            backtrack(row + 1)
            
            # Remove queen (backtrack)
            board[row][col] = '.'
            cols.remove(col)
            diags.remove(row - col)
            anti_diags.remove(row + col)
    
    backtrack(0)
    return result
\end{lstlisting}
\textbf{Complexity:} Time $O(N!)$, Space $O(N)$

\section{N-Queens II}
\subsection*{Problem Description}
Return number of distinct N-Queens solutions.

\subsection*{Solution Approach}
\begin{itemize}
    \item Similar to N-Queens but count solutions instead of storing boards.
    \item Use backtracking with pruning.
    \item Track attacked positions efficiently.
\end{itemize}

\subsection*{Key Algorithms}
Backtracking

\subsection*{Edge Cases}
Same as N-Queens.

\begin{lstlisting}[language=Python]
def totalNQueens(n: int) -> int:
    cols = set()
    diags = set()
    anti_diags = set()
    
    def backtrack(row: int) -> int:
        if row == n:
            return 1
        
        count = 0
        for col in range(n):
            if col in cols or (row - col) in diags or (row + col) in anti_diags:
                continue
            
            # Place queen
            cols.add(col)
            diags.add(row - col)
            anti_diags.add(row + col)
            
            count += backtrack(row + 1)
            
            # Remove queen
            cols.remove(col)
            diags.remove(row - col)
            anti_diags.remove(row + col)
        
        return count
    
    return backtrack(0)
\end{lstlisting}
\textbf{Complexity:} Time $O(N!)$, Space $O(N)$

\section{Permutation Sequence}
\subsection*{Problem Description}
Return the kth permutation sequence of numbers 1 to n.

\subsection*{Solution Approach}
\begin{itemize}
    \item Use factorial number system.
    \item Determine which number goes in each position.
    \item \texttt{k-1} divided by \texttt{(n-1)!} gives index of first number.
    \item Update k and repeat for remaining positions.
\end{itemize}

\subsection*{Key Algorithms}
Math, Factorial Number System

\subsection*{Edge Cases}
k = 1 (first permutation), k = n! (last permutation).

\begin{lstlisting}[language=Python]
def getPermutation(n: int, k: int) -> str:
    # Calculate factorials
    factorial = [1] * n
    for i in range(1, n):
        factorial[i] = factorial[i - 1] * i
    
    # Available numbers
    numbers = list(range(1, n + 1))
    result = []
    
    # Convert to 0-indexed
    k -= 1
    
    # Build permutation digit by digit
    for i in range(n, 0, -1):
        # Find which number to use
        index = k // factorial[i - 1]
        result.append(str(numbers[index]))
        numbers.pop(index)
        
        # Update k for next position
        k %= factorial[i - 1]
    
    return ''.join(result)
\end{lstlisting}
\textbf{Complexity:} Time $O(n^2)$, Space $O(n)$

\section{Valid Number}
\subsection*{Problem Description}
Validate if string is a valid decimal number.

\subsection*{Solution Approach}
\begin{itemize}
    \item Use finite state machine or careful parsing.
    \item Handle signs, digits, decimal point, exponent.
    \item Check valid transitions between components.
    \item Ensure required parts are present.
\end{itemize}

\subsection*{Key Algorithms}
String Parsing, State Machine

\subsection*{Edge Cases}
Leading/trailing spaces, multiple signs/decimals, 'e' without digits.

\begin{lstlisting}[language=Python]
def isNumber(s: str) -> bool:
    s = s.strip()
    if not s:
        return False
    
    # Flags to track what we've seen
    num_seen = dot_seen = e_seen = False
    num_after_e = True
    
    for i, char in enumerate(s):
        if char.isdigit():
            num_seen = True
            num_after_e = True
        elif char == '.':
            # Can't have dot after 'e' or second dot
            if e_seen or dot_seen:
                return False
            dot_seen = True
        elif char in 'eE':
            # Must have number before 'e' and can't have second 'e'
            if e_seen or not num_seen:
                return False
            e_seen = True
            num_after_e = False
        elif char in '+-':
            # Sign only at start or right after 'e'
            if i > 0 and s[i - 1] not in 'eE':
                return False
        else:
            return False
    
    # Must have at least one number and number after 'e' if present
    return num_seen and num_after_e
\end{lstlisting}
\textbf{Complexity:} Time $O(n)$, Space $O(1)$

\section{Text Justification}
\subsection*{Problem Description}
Format text with full justification given max width per line.

\subsection*{Solution Approach}
\begin{itemize}
    \item Pack words into lines greedily.
    \item Distribute spaces evenly between words.
    \item Extra spaces go to leftmost gaps.
    \item Last line is left-justified.
\end{itemize}

\subsection*{Key Algorithms}
Greedy, String Manipulation

\subsection*{Edge Cases}
Single word per line, last line, one word exceeds maxWidth.

\begin{lstlisting}[language=Python]
def fullJustify(words: List[str], maxWidth: int) -> List[str]:
    result = []
    current_line = []
    current_length = 0
    
    for word in words:
        # Check if word fits in current line
        if current_length + len(word) + len(current_line) > maxWidth:
            # Justify current line
            if len(current_line) == 1:
                # Single word - left justify
                result.append(current_line[0] + ' ' * (maxWidth - len(current_line[0])))
            else:
                # Multiple words - full justify
                total_spaces = maxWidth - current_length
                gaps = len(current_line) - 1
                spaces_per_gap = total_spaces // gaps
                extra_spaces = total_spaces % gaps
                
                line = ''
                for i, w in enumerate(current_line):
                    line += w
                    if i < gaps:
                        line += ' ' * spaces_per_gap
                        if i < extra_spaces:
                            line += ' '
                
                result.append(line)
            
            # Start new line
            current_line = [word]
            current_length = len(word)
        else:
            current_line.append(word)
            current_length += len(word)
    
    # Handle last line (left-justified)
    last_line = ' '.join(current_line)
    result.append(last_line + ' ' * (maxWidth - len(last_line)))
    
    return result
\end{lstlisting}
\textbf{Complexity:} Time $O(n)$, Space $O(n)$

\section{Minimum Window Substring}
\subsection*{Problem Description}
Find minimum window in `s` containing all characters of `t`.

\subsection*{Solution Approach}
\begin{itemize}
    \item Use sliding window with two pointers.
    \item Expand window until all chars included.
    \item Contract window while maintaining validity.
    \item Track minimum window seen.
\end{itemize}

\subsection*{Key Algorithms}
Sliding Window, Hash Map

\subsection*{Edge Cases}
No valid window, `t` longer than `s`, duplicate chars in `t`.

\begin{lstlisting}[language=Python]
from collections import Counter

def minWindow(s: str, t: str) -> str:
    if not s or not t:
        return ""
    
    # Count characters in t
    dict_t = Counter(t)
    required = len(dict_t)
    
    # Sliding window
    left = right = 0
    formed = 0  # Number of unique chars in window with desired frequency
    
    # Count of chars in current window
    window_counts = {}
    
    # Result
    min_len = float('inf')
    min_left = 0
    
    while right < len(s):
        # Expand window
        char = s[right]
        window_counts[char] = window_counts.get(char, 0) + 1
        
        if char in dict_t and window_counts[char] == dict_t[char]:
            formed += 1
        
        # Contract window
        while left <= right and formed == required:
            # Update result
            if right - left + 1 < min_len:
                min_len = right - left + 1
                min_left = left
            
            # Remove from left
            char = s[left]
            window_counts[char] -= 1
            if char in dict_t and window_counts[char] < dict_t[char]:
                formed -= 1
            
            left += 1
        
        right += 1
    
    return "" if min_len == float('inf') else s[min_left:min_left + min_len]
\end{lstlisting}
\textbf{Complexity:} Time $O(|s| + |t|)$, Space $O(|s| + |t|)$

\section{Largest Rectangle in Histogram}
\subsection*{Problem Description}
Find largest rectangle area in histogram.

\subsection*{Solution Approach}
\begin{itemize}
    \item Use stack to track indices of increasing heights.
    \item When smaller height found, calculate areas.
    \item Pop from stack until current height fits.
    \item Calculate area using popped height and width.
\end{itemize}

\subsection*{Key Algorithms}
Stack, Monotonic Stack

\subsection*{Edge Cases}
All same height, strictly increasing/decreasing, single bar.

\begin{lstlisting}[language=Python]
def largestRectangleArea(heights: List[int]) -> int:
    stack = []  # Indices of bars
    max_area = 0
    
    for i, height in enumerate(heights):
        # Pop bars taller than current
        while stack and heights[stack[-1]] > height:
            h_index = stack.pop()
            h = heights[h_index]
            # Width is from previous bar in stack to current position
            w = i if not stack else i - stack[-1] - 1
            max_area = max(max_area, h * w)
        
        stack.append(i)
    
    # Process remaining bars
    while stack:
        h_index = stack.pop()
        h = heights[h_index]
        w = len(heights) if not stack else len(heights) - stack[-1] - 1
        max_area = max(max_area, h * w)
    
    return max_area
\end{lstlisting}
\textbf{Complexity:} Time $O(n)$, Space $O(n)$

\section{Maximal Rectangle}
\subsection*{Problem Description}
Find largest rectangle containing only 1s in binary matrix.

\subsection*{Solution Approach}
\begin{itemize}
    \item Transform to histogram problem for each row.
    \item \texttt{Height[j]} = consecutive 1s above in column j.
    \item Apply largest rectangle in histogram to each row.
    \item Track maximum across all rows.
\end{itemize}

\subsection*{Key Algorithms}
Dynamic Programming, Stack

\subsection*{Edge Cases}
All 0s, all 1s, single row/column.

\begin{lstlisting}[language=Python]
def maximalRectangle(matrix: List[List[str]]) -> int:
    if not matrix or not matrix[0]:
        return 0
    
    rows, cols = len(matrix), len(matrix[0])
    heights = [0] * cols
    max_area = 0
    
    for row in matrix:
        # Update heights for current row
        for j in range(cols):
            if row[j] == '1':
                heights[j] += 1
            else:
                heights[j] = 0
        
        # Find max rectangle in this histogram
        max_area = max(max_area, largestRectangleArea(heights))
    
    return max_area

def largestRectangleArea(heights: List[int]) -> int:
    stack = []
    max_area = 0
    
    for i, height in enumerate(heights):
        while stack and heights[stack[-1]] > height:
            h_index = stack.pop()
            h = heights[h_index]
            w = i if not stack else i - stack[-1] - 1
            max_area = max(max_area, h * w)
        stack.append(i)
    
    while stack:
        h_index = stack.pop()
        h = heights[h_index]
        w = len(heights) if not stack else len(heights) - stack[-1] - 1
        max_area = max(max_area, h * w)
    
    return max_area
\end{lstlisting}
\textbf{Complexity:} Time $O(\text{rows} \times \text{cols})$, Space $O(\text{cols})$

\section{Scramble String}
\subsection*{Problem Description}
Check if `s2` is scrambled string of `s1` (binary tree scrambling).

\subsection*{Solution Approach}
\begin{itemize}
    \item Use recursion with memoization.
    \item Try all possible split points.
    \item Check both non-swapped and swapped cases.
    \item Base case: strings are equal.
\end{itemize}

\subsection*{Key Algorithms}
Recursion, Memoization

\subsection*{Edge Cases}
Same strings, single character, anagrams.

\begin{lstlisting}[language=Python]
from functools import lru_cache

def isScramble(s1: str, s2: str) -> bool:
    @lru_cache(None)
    def helper(s1: str, s2: str) -> bool:
        # Base cases
        if s1 == s2:
            return True
        
        if sorted(s1) != sorted(s2):
            return False
        
        n = len(s1)
        
        # Try all split points
        for i in range(1, n):
            # Case 1: No swap
            if helper(s1[:i], s2[:i]) and helper(s1[i:], s2[i:]):
                return True
            
            # Case 2: Swap
            if helper(s1[:i], s2[-i:]) and helper(s1[i:], s2[:-i]):
                return True
        
        return False
    
    return helper(s1, s2)
\end{lstlisting}
\textbf{Complexity:} Time $O(n^4)$, Space $O(n^3)$

\section{Distinct Subsequences}
\subsection*{Problem Description}
Count distinct subsequences of `s` that equal `t`.

\subsection*{Solution Approach}
\begin{itemize}
    \item Use dynamic programming.
    \item \texttt{dp[i][j]} = ways to form \texttt{t[0:j]} from \texttt{s[0:i]}.
    \item If \texttt{s[i-1] == t[j-1]}: can use or skip \texttt{s[i-1]}.
    \item Otherwise: must skip \texttt{s[i-1]}.
\end{itemize}

\subsection*{Key Algorithms}
Dynamic Programming

\subsection*{Edge Cases}
Empty `t` (return 1), `t` longer than `s` (return 0).

\begin{lstlisting}[language=Python]
def numDistinct(s: str, t: str) -> int:
    m, n = len(s), len(t)
    
    # dp[i][j] = number of ways to form t[0:j] from s[0:i]
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # Empty t can be formed in one way (delete all)
    for i in range(m + 1):
        dp[i][0] = 1
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            # Skip s[i-1]
            dp[i][j] = dp[i - 1][j]
            
            # Use s[i-1] if it matches t[j-1]
            if s[i - 1] == t[j - 1]:
                dp[i][j] += dp[i - 1][j - 1]
    
    return dp[m][n]
\end{lstlisting}
\textbf{Complexity:} Time $O(mn)$, Space $O(mn)$

\section{Best Time to Buy and Sell Stock III}
\subsection*{Problem Description}
Maximum profit with at most 2 transactions.

\subsection*{Solution Approach}
\begin{itemize}
    \item Track 4 states: after buy1, sell1, buy2, sell2.
    \item Update states for each price.
    \item \texttt{buy1} = max profit after first buy.
    \item \texttt{sell2} = max profit after second sell.
\end{itemize}

\subsection*{Key Algorithms}
State Machine, Dynamic Programming

\subsection*{Edge Cases}
Prices always decrease, single price, need only 1 transaction.

\begin{lstlisting}[language=Python]
def maxProfit(prices: List[int]) -> int:
    if not prices:
        return 0
    
    # State variables
    buy1 = -prices[0]  # Max profit after first buy
    sell1 = 0          # Max profit after first sell
    buy2 = -prices[0]  # Max profit after second buy
    sell2 = 0          # Max profit after second sell
    
    for price in prices[1:]:
        # Update in reverse order to avoid using updated values
        sell2 = max(sell2, buy2 + price)
        buy2 = max(buy2, sell1 - price)
        sell1 = max(sell1, buy1 + price)
        buy1 = max(buy1, -price)
    
    return sell2
\end{lstlisting}
\textbf{Complexity:} Time $O(n)$, Space $O(1)$

\section{Binary Tree Maximum Path Sum}
\subsection*{Problem Description}
Find maximum path sum in binary tree (path can start/end anywhere).

\subsection*{Solution Approach}
\begin{itemize}
    \item Use DFS to explore all paths.
    \item At each node, calculate max path through node.
    \item Return max path starting from node to parent.
    \item Track global maximum.
\end{itemize}

\subsection*{Key Algorithms}
DFS, Tree Traversal

\subsection*{Edge Cases}
All negative values, single node, straight line tree.

\begin{lstlisting}[language=Python]
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def maxPathSum(root: Optional[TreeNode]) -> int:
    max_sum = float('-inf')
    
    def max_gain(node: Optional[TreeNode]) -> int:
        nonlocal max_sum
        
        if not node:
            return 0
        
        # Max sum starting from left/right child
        left_gain = max(max_gain(node.left), 0)
        right_gain = max(max_gain(node.right), 0)
        
        # Max path through current node
        current_max = node.val + left_gain + right_gain
        max_sum = max(max_sum, current_max)
        
        # Return max gain if we continue path through parent
        return node.val + max(left_gain, right_gain)
    
    max_gain(root)
    return max_sum
\end{lstlisting}
\textbf{Complexity:} Time $O(n)$, Space $O(h)$ where h = height

\section{Word Ladder II}
\subsection*{Problem Description}
Find all shortest transformation sequences from `beginWord` to `endWord`.

\subsection*{Solution Approach}
\begin{itemize}
    \item BFS to find shortest path length.
    \item Build adjacency graph during BFS.
    \item DFS/backtrack to find all paths of shortest length.
    \item Prune paths that can't reach end in time.
\end{itemize}

\subsection*{Key Algorithms}
BFS, DFS, Graph

\subsection*{Edge Cases}
No path exists, multiple shortest paths, `beginWord` = `endWord`.

\begin{lstlisting}[language=Python]
from collections import defaultdict, deque

def findLadders(beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:
    if endWord not in wordList:
        return []
    
    # Build adjacency list
    neighbors = defaultdict(list)
    wordList.append(beginWord)
    
    for word in wordList:
        for i in range(len(word)):
            pattern = word[:i] + '*' + word[i + 1:]
            neighbors[pattern].append(word)
    
    # BFS to find shortest path and build graph
    visited = {beginWord}
    queue = deque([beginWord])
    found = False
    adjacency = defaultdict(list)
    
    while queue and not found:
        next_visited = set()
        for _ in range(len(queue)):
            word = queue.popleft()
            for i in range(len(word)):
                pattern = word[:i] + '*' + word[i + 1:]
                for neighbor in neighbors[pattern]:
                    if neighbor == endWord:
                        found = True
                    if neighbor not in visited:
                        if neighbor not in next_visited:
                            next_visited.add(neighbor)
                            queue.append(neighbor)
                        adjacency[word].append(neighbor)
        visited.update(next_visited)
    
    # DFS to find all shortest paths
    result = []
    
    def dfs(word: str, path: List[str]) -> None:
        if word == endWord:
            result.append(path[:])
            return
        
        for next_word in adjacency[word]:
            path.append(next_word)
            dfs(next_word, path)
            path.pop()
    
    if found:
        dfs(beginWord, [beginWord])
    
    return result
\end{lstlisting}
\textbf{Complexity:} Time $O(N \times L^2)$ where N = words, L = length, Space $O(N \times L)$

\section{Word Ladder}
\subsection*{Problem Description}
Find length of shortest transformation sequence from `beginWord` to `endWord`.

\subsection*{Solution Approach}
\begin{itemize}
    \item BFS from `beginWord`.
    \item Generate all possible one-letter transformations.
    \item Check if transformation is in `wordList`.
    \item Track visited to avoid cycles.
\end{itemize}

\subsection*{Key Algorithms}
BFS, Hash Set

\subsection*{Edge Cases}
No path, `beginWord` = `endWord`, `endWord` not in list.

\begin{lstlisting}[language=Python]
def ladderLength(beginWord: str, endWord: str, wordList: List[str]) -> int:
    if endWord not in wordList:
        return 0
    
    wordSet = set(wordList)
    queue = deque([(beginWord, 1)])
    visited = {beginWord}
    
    while queue:
        word, length = queue.popleft()
        
        if word == endWord:
            return length
        
        # Try all one-letter transformations
        for i in range(len(word)):
            for c in 'abcdefghijklmnopqrstuvwxyz':
                if c == word[i]:
                    continue
                    
                next_word = word[:i] + c + word[i + 1:]
                
                if next_word in wordSet and next_word not in visited:
                    visited.add(next_word)
                    queue.append((next_word, length + 1))
    
    return 0
\end{lstlisting}
\textbf{Complexity:} Time $O(N \times L^2 \times 26)$, Space $O(N \times L)$

\section{Palindrome Partitioning II}
\subsection*{Problem Description}
Minimum cuts needed to partition string into palindromes.

\subsection*{Solution Approach}
\begin{itemize}
    \item Precompute palindrome table.
    \item \texttt{dp[i]} = minimum cuts for \texttt{s[0:i]}.
    \item For each position, try all palindrome endings.
    \item Update minimum cuts needed.
\end{itemize}

\subsection*{Key Algorithms}
Dynamic Programming

\subsection*{Edge Cases}
Already palindrome (0 cuts), single chars, no palindromes > 1.

\begin{lstlisting}[language=Python]
def minCut(s: str) -> int:
    n = len(s)
    
    # Precompute palindrome table
    is_palindrome = [[False] * n for _ in range(n)]
    
    for right in range(n):
        for left in range(right + 1):
            if s[left] == s[right] and (right - left <= 2 or is_palindrome[left + 1][right - 1]):
                is_palindrome[left][right] = True
    
    # dp[i] = minimum cuts for s[0:i]
    dp = [float('inf')] * (n + 1)
    dp[0] = -1  # Empty string needs -1 cuts
    
    for i in range(1, n + 1):
        for j in range(i):
            if is_palindrome[j][i - 1]:
                dp[i] = min(dp[i], dp[j] + 1)
    
    return dp[n]
\end{lstlisting}
\textbf{Complexity:} Time $O(n^2)$, Space $O(n^2)$

\section{Candy}
\subsection*{Problem Description}
Minimum candies to give children where higher rating gets more candy than neighbors.

\subsection*{Solution Approach}
\begin{itemize}
    \item Two passes: left-to-right and right-to-left.
    \item Left pass: ensure higher rating than left gets more.
    \item Right pass: ensure higher rating than right gets more.
    \item Take maximum of both requirements.
\end{itemize}

\subsection*{Key Algorithms}
Greedy, Two Pass

\subsection*{Edge Cases}
All same ratings, strictly increasing/decreasing.

\begin{lstlisting}[language=Python]
def candy(ratings: List[int]) -> int:
    n = len(ratings)
    candies = [1] * n
    
    # Left to right pass
    for i in range(1, n):
        if ratings[i] > ratings[i - 1]:
            candies[i] = candies[i - 1] + 1
    
    # Right to left pass
    for i in range(n - 2, -1, -1):
        if ratings[i] > ratings[i + 1]:
            candies[i] = max(candies[i], candies[i + 1] + 1)
    
    return sum(candies)
\end{lstlisting}
\textbf{Complexity:} Time $O(n)$, Space $O(n)$

\section{Word Break II}
\subsection*{Problem Description}
Return all possible sentences by breaking `s` using dictionary words.

\subsection*{Solution Approach}
\begin{itemize}
    \item Use backtracking with memoization.
    \item Try each prefix that's a valid word.
    \item Recursively break remaining string.
    \item Combine results.
\end{itemize}

\subsection*{Key Algorithms}
Backtracking, Memoization

\subsection*{Edge Cases}
No valid breaks, multiple ways to break, overlapping words.

\begin{lstlisting}[language=Python]
def wordBreak(s: str, wordDict: List[str]) -> List[str]:
    word_set = set(wordDict)
    memo = {}
    
    def backtrack(start: int) -> List[str]:
        if start in memo:
            return memo[start]
        
        if start == len(s):
            return ['']
        
        sentences = []
        
        for end in range(start + 1, len(s) + 1):
            word = s[start:end]
            if word in word_set:
                # Recursively break the rest
                for sub_sentence in backtrack(end):
                    if sub_sentence:
                        sentences.append(word + ' ' + sub_sentence)
                    else:
                        sentences.append(word)
        
        memo[start] = sentences
        return sentences
    
    return backtrack(0)
\end{lstlisting}
\textbf{Complexity:} Time $O(n^3)$, Space $O(n^3)$

\section{Max Points on a Line}
\subsection*{Problem Description}
Maximum number of points on the same straight line.

\subsection*{Solution Approach}
\begin{itemize}
    \item For each point as origin, calculate slopes to others.
    \item Use hash map to count points with same slope.
    \item Handle vertical lines and same points specially.
    \item Use GCD to normalize slopes.
\end{itemize}

\subsection*{Key Algorithms}
Hash Map, GCD

\subsection*{Edge Cases}
Duplicate points, vertical lines, all points collinear.

\begin{lstlisting}[language=Python]
from math import gcd
from collections import defaultdict

def maxPoints(points: List[List[int]]) -> int:
    if len(points) <= 2:
        return len(points)
    
    max_points = 0
    
    for i in range(len(points)):
        slopes = defaultdict(int)
        same_point = 1
        local_max = 0
        
        for j in range(i + 1, len(points)):
            dx = points[j][0] - points[i][0]
            dy = points[j][1] - points[i][1]
            
            if dx == 0 and dy == 0:
                same_point += 1
            else:
                # Normalize slope using GCD
                g = gcd(dx, dy)
                dx, dy = dx // g, dy // g
                
                # Ensure consistent sign
                if dx < 0:
                    dx, dy = -dx, -dy
                elif dx == 0:
                    dy = abs(dy)
                
                slopes[(dx, dy)] += 1
                local_max = max(local_max, slopes[(dx, dy)])
        
        max_points = max(max_points, local_max + same_point)
    
    return max_points
\end{lstlisting}
\textbf{Complexity:} Time $O(n^2)$, Space $O(n)$

\section{Find Minimum in Rotated Sorted Array II}
\subsection*{Problem Description}
Find minimum in rotated sorted array with duplicates.

\subsection*{Solution Approach}
\begin{itemize}
    \item Modified binary search.
    \item Compare mid with right endpoint.
    \item If equal, can't determine side, reduce search space by 1.
    \item Otherwise, binary search on correct half.
\end{itemize}

\subsection*{Key Algorithms}
Binary Search

\subsection*{Edge Cases}
No rotation, all duplicates, single element.

\begin{lstlisting}[language=Python]
def findMin(nums: List[int]) -> int:
    left, right = 0, len(nums) - 1
    
    while left < right:
        mid = (left + right) // 2
        
        if nums[mid] > nums[right]:
            # Minimum is in right half
            left = mid + 1
        elif nums[mid] < nums[right]:
            # Minimum is in left half (including mid)
            right = mid
        else:
            # nums[mid] == nums[right], can't determine
            # Safely reduce search space
            right -= 1
    
    return nums[left]
\end{lstlisting}
\textbf{Complexity:} Time $O(n)$ worst case, $O(\log n)$ average, Space $O(1)$

\section{Read N Characters Given read4 II - Call Multiple Times}
\subsection*{Problem Description}
Implement `read` method using `read4` that can be called multiple times.

\subsection*{Solution Approach}
\begin{itemize}
    \item Maintain internal buffer between calls.
    \item Read from buffer first if available.
    \item Call `read4` to refill buffer when needed.
    \item Handle partial reads correctly.
\end{itemize}

\subsection*{Key Algorithms}
Buffer Management

\subsection*{Edge Cases}
Multiple calls, buffer boundary, EOF handling.

\begin{lstlisting}[language=Python]
class Solution:
    def __init__(self):
        self.buffer = [''] * 4
        self.buffer_ptr = 0
        self.buffer_count = 0
    
    def read(self, buf: List[str], n: int) -> int:
        total_read = 0
        
        while total_read < n:
            # Read from buffer first
            if self.buffer_ptr < self.buffer_count:
                buf[total_read] = self.buffer[self.buffer_ptr]
                self.buffer_ptr += 1
                total_read += 1
            else:
                # Buffer empty, read more
                self.buffer_count = read4(self.buffer)
                self.buffer_ptr = 0
                
                if self.buffer_count == 0:
                    break
        
        return total_read
\end{lstlisting}
\textbf{Complexity:} Time $O(n)$, Space $O(1)$

\section{Dungeon Game}
\subsection*{Problem Description}
Minimum initial health to reach bottom-right rescuing princess.

\subsection*{Solution Approach}
\begin{itemize}
    \item Work backwards from destination.
    \item \texttt{dp[i][j]} = minimum health needed at \texttt{(i,j)}.
    \item Need at least 1 health after any cell.
    \item Calculate based on minimum of right/down paths.
\end{itemize}

\subsection*{Key Algorithms}
Dynamic Programming

\subsection*{Edge Cases}
All positive values, large negative values, single cell.

\begin{lstlisting}[language=Python]
def calculateMinimumHP(dungeon: List[List[int]]) -> int:
    m, n = len(dungeon), len(dungeon[0])
    
    # dp[i][j] = minimum health needed to reach bottom-right from (i,j)
    dp = [[float('inf')] * (n + 1) for _ in range(m + 1)]
    dp[m][n - 1] = dp[m - 1][n] = 1
    
    # Work backwards
    for i in range(m - 1, -1, -1):
        for j in range(n - 1, -1, -1):
            # Minimum health needed for next step
            min_health = min(dp[i + 1][j], dp[i][j + 1])
            
            # Health needed at current cell
            dp[i][j] = max(1, min_health - dungeon[i][j])
    
    return dp[0][0]
\end{lstlisting}
\textbf{Complexity:} Time $O(mn)$, Space $O(mn)$

\section{Best Time to Buy and Sell Stock IV}
\subsection*{Problem Description}
Maximum profit with at most `k` transactions.

\subsection*{Solution Approach}
\begin{itemize}
    \item If `k >= n/2`, unlimited transactions.
    \item \texttt{dp[i][j]} = max profit with at most \texttt{i} transactions by day \texttt{j}.
    \item Track max profit after buying for each transaction.
    \item Update based on sell or hold.
\end{itemize}

\subsection*{Key Algorithms}
Dynamic Programming

\subsection*{Edge Cases}
`k = 0`, `k >= n/2` (unlimited), prices decreasing.

\begin{lstlisting}[language=Python]
def maxProfit(k: int, prices: List[int]) -> int:
    if not prices or k == 0:
        return 0
    
    n = len(prices)
    
    # If k >= n/2, unlimited transactions
    if k >= n // 2:
        profit = 0
        for i in range(1, n):
            profit += max(0, prices[i] - prices[i - 1])
        return profit
    
    # dp[i][0] = max profit after at most i transactions and not holding
    # dp[i][1] = max profit after at most i transactions and holding
    dp = [[0, -prices[0]] for _ in range(k + 1)]
    
    for price in prices[1:]:
        for i in range(k, 0, -1):
            dp[i][0] = max(dp[i][0], dp[i][1] + price)
            dp[i][1] = max(dp[i][1], dp[i - 1][0] - price)
    
    return dp[k][0]
\end{lstlisting}
\textbf{Complexity:} Time $O(nk)$, Space $O(k)$

\section{Word Search II}
\subsection*{Problem Description}
Find all words from dictionary in 2D board.

\subsection*{Solution Approach}
\begin{itemize}
    \item Build Trie from word list.
    \item DFS from each cell.
    \item Track current path in Trie.
    \item Mark found words to avoid duplicates.
\end{itemize}

\subsection*{Key Algorithms}
Trie, DFS, Backtracking

\subsection*{Edge Cases}
No words found, overlapping words, word prefix of another.

\begin{lstlisting}[language=Python]
class TrieNode:
    def __init__(self):
        self.children = {}
        self.word = None

def findWords(board: List[List[str]], words: List[str]) -> List[str]:
    # Build Trie
    root = TrieNode()
    for word in words:
        node = root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.word = word
    
    m, n = len(board), len(board[0])
    result = []
    
    def dfs(i: int, j: int, node: TrieNode) -> None:
        if i < 0 or i >= m or j < 0 or j >= n:
            return
        
        char = board[i][j]
        if char not in node.children or char == '#':
            return
        
        node = node.children[char]
        
        if node.word:
            result.append(node.word)
            node.word = None  # Avoid duplicates
        
        # Mark as visited
        board[i][j] = '#'
        
        # Explore neighbors
        dfs(i + 1, j, node)
        dfs(i - 1, j, node)
        dfs(i, j + 1, node)
        dfs(i, j - 1, node)
        
        # Restore
        board[i][j] = char
    
    for i in range(m):
        for j in range(n):
            dfs(i, j, root)
    
    return result
\end{lstlisting}
\textbf{Complexity:} Time $O(m \times n \times 4^L)$ where L = max word length, Space $O(\text{total chars})$

\section{Shortest Palindrome}
\subsection*{Problem Description}
Find shortest palindrome by adding characters in front.

\subsection*{Solution Approach}
\begin{itemize}
    \item Find longest palindrome starting from index 0.
    \item Use KMP algorithm's failure function.
    \item Create string \texttt{s + "\#" + reverse(s)}.
    \item LPS value gives longest palindrome prefix.
\end{itemize}

\subsection*{Key Algorithms}
KMP Algorithm, String Matching

\subsection*{Edge Cases}
Already palindrome, single character, no palindrome prefix.

\begin{lstlisting}[language=Python]
def shortestPalindrome(s: str) -> str:
    if not s:
        return s
    
    # Create combined string for KMP
    combined = s + '#' + s[::-1]
    
    # Build KMP failure function
    n = len(combined)
    lps = [0] * n
    
    for i in range(1, n):
        j = lps[i - 1]
        
        while j > 0 and combined[i] != combined[j]:
            j = lps[j - 1]
        
        if combined[i] == combined[j]:
            j += 1
        
        lps[i] = j
    
    # Length of longest palindrome prefix
    palindrome_len = lps[-1]
    
    # Add reverse of remaining suffix to front
    return s[palindrome_len:][::-1] + s
\end{lstlisting}
\textbf{Complexity:} Time $O(n)$, Space $O(n)$

\section{The Skyline Problem}
\subsection*{Problem Description}
Output skyline formed by buildings.

\subsection*{Solution Approach}
\begin{itemize}
    \item Create events for building start/end.
    \item Sort events by position, then by height.
    \item Use multiset/heap to track active buildings.
    \item Add key point when max height changes.
\end{itemize}

\subsection*{Key Algorithms}
Sweep Line, Priority Queue

\subsection*{Edge Cases}
Overlapping buildings, same height, touching buildings.

\begin{lstlisting}[language=Python]
import heapq

def getSkyline(buildings: List[List[int]]) -> List[List[int]]:
    # Create events: (position, is_start, height)
    events = []
    for left, right, height in buildings:
        events.append((left, True, height))
        events.append((right, False, height))
    
    # Sort events
    events.sort(key=lambda x: (x[0], not x[1], -x[2] if x[1] else x[2]))
    
    result = []
    heights = [0]  # Min heap (use negative for max heap)
    
    for pos, is_start, height in events:
        if is_start:
            heapq.heappush(heights, -height)
        else:
            heights.remove(-height)
            heapq.heapify(heights)
        
        # Current max height
        max_height = -heights[0]
        
        # Add key point if height changed
        if not result or result[-1][1] != max_height:
            result.append([pos, max_height])
    
    return result
\end{lstlisting}
\textbf{Complexity:} Time $O(n^2 \log n)$, Space $O(n)$

\section{Contains Duplicate III}
\subsection*{Problem Description}
Check if array has two indices `i,j` where `|nums[i]-nums[j]| <= valueDiff` and `|i-j| <= indexDiff`.

\subsection*{Solution Approach}
\begin{itemize}
    \item Use sliding window with ordered set.
    \item For each element, check range \texttt{[num-valueDiff, num+valueDiff]}.
    \item Maintain window size of \texttt{indexDiff}.
    \item Use buckets for O(n) solution.
\end{itemize}

\subsection*{Key Algorithms}
Sliding Window, Bucket Sort

\subsection*{Edge Cases}
`valueDiff = 0`, `indexDiff = 0`, negative numbers.

\begin{lstlisting}[language=Python]
def containsNearbyAlmostDuplicate(nums: List[int], indexDiff: int, valueDiff: int) -> bool:
    if indexDiff < 1 or valueDiff < 0:
        return False
    
    # Bucket approach
    buckets = {}
    bucket_size = valueDiff + 1
    
    for i, num in enumerate(nums):
        # Determine bucket
        bucket_id = num // bucket_size
        
        # Check current bucket
        if bucket_id in buckets:
            return True
        
        # Check adjacent buckets
        if bucket_id - 1 in buckets and abs(num - buckets[bucket_id - 1]) <= valueDiff:
            return True
        if bucket_id + 1 in buckets and abs(num - buckets[bucket_id + 1]) <= valueDiff:
            return True
        
        # Add to bucket
        buckets[bucket_id] = num
        
        # Remove old element
        if i >= indexDiff:
            old_bucket = nums[i - indexDiff] // bucket_size
            del buckets[old_bucket]
    
    return False
\end{lstlisting}
\textbf{Complexity:} Time $O(n)$, Space $O(\min(n, \text{indexDiff}))$

\section{Basic Calculator}
\subsection*{Problem Description}
Evaluate expression with `+`, `-`, `(`, `)`.

\subsection*{Solution Approach}
\begin{itemize}
    \item Use stack to handle parentheses.
    \item Track current number and sign.
    \item When `(` found, push current result and sign.
    \item When `)` found, pop and combine with previous.
\end{itemize}

\subsection*{Key Algorithms}
Stack

\subsection*{Edge Cases}
Nested parentheses, negative numbers, spaces.

\begin{lstlisting}[language=Python]
def calculate(s: str) -> int:
    stack = []
    result = 0
    number = 0
    sign = 1
    
    for char in s:
        if char.isdigit():
            number = number * 10 + int(char)
        elif char == '+':
            result += sign * number
            number = 0
            sign = 1
        elif char == '-':
            result += sign * number
            number = 0
            sign = -1
        elif char == '(':
            # Push current result and sign
            stack.append(result)
            stack.append(sign)
            result = 0
            sign = 1
        elif char == ')':
            result += sign * number
            number = 0
            # Pop sign and previous result
            result = stack.pop() * result + stack.pop()
    
    # Handle last number
    result += sign * number
    
    return result
\end{lstlisting}
\textbf{Complexity:} Time $O(n)$, Space $O(n)$

\section{Number of Digit One}
\subsection*{Problem Description}
Count total occurrences of digit 1 in all numbers from 1 to `n`.

\subsection*{Solution Approach}
\begin{itemize}
    \item Count digit by digit position.
    \item For each position, count complete cycles and remainder.
    \item Handle current digit cases: 0, 1, or >1.
    \item Sum counts for all positions.
\end{itemize}

\subsection*{Key Algorithms}
Math, Digital DP

\subsection*{Edge Cases}
`n = 0`, single digit numbers, powers of 10.

\begin{lstlisting}[language=Python]
def countDigitOne(n: int) -> int:
    if n <= 0:
        return 0
    
    count = 0
    factor = 1
    
    while factor <= n:
        # Divide number into parts
        lower = n % factor
        current = (n // factor) % 10
        higher = n // (factor * 10)
        
        if current == 0:
            count += higher * factor
        elif current == 1:
            count += higher * factor + lower + 1
        else:
            count += (higher + 1) * factor
        
        factor *= 10
    
    return count
\end{lstlisting}
\textbf{Complexity:} Time $O(\log n)$, Space $O(1)$

\section{Sliding Window Maximum}
\subsection*{Problem Description}
Maximum value in each sliding window of size `k`.

\subsection*{Solution Approach}
\begin{itemize}
    \item Use deque to maintain decreasing order.
    \item Remove elements outside window.
    \item Remove smaller elements from right.
    \item Front of deque is always maximum.
\end{itemize}

\subsection*{Key Algorithms}
Deque, Monotonic Queue

\subsection*{Edge Cases}
`k = 1`, `k = n`, all same values.

\begin{lstlisting}[language=Python]
from collections import deque

def maxSlidingWindow(nums: List[int], k: int) -> List[int]:
    if not nums or k == 0:
        return []
    
    # Deque stores indices
    dq = deque()
    result = []
    
    for i, num in enumerate(nums):
        # Remove indices outside window
        while dq and dq[0] <= i - k:
            dq.popleft()
        
        # Remove smaller elements from right
        while dq and nums[dq[-1]] <= num:
            dq.pop()
        
        dq.append(i)
        
        # Add to result after first window
        if i >= k - 1:
            result.append(nums[dq[0]])
    
    return result
\end{lstlisting}
\textbf{Complexity:} Time $O(n)$, Space $O(k)$

\section{Strobogrammatic Number III}
\subsection*{Problem Description}
Count strobogrammatic numbers in range `[low, high]`.

\subsection*{Solution Approach}
\begin{itemize}
    \item Generate all strobogrammatic numbers of each length.
    \item Use recursion to build from middle outward.
    \item Count those within range.
    \item Handle edge cases for leading zeros.
\end{itemize}

\subsection*{Key Algorithms}
Recursion, String Building

\subsection*{Edge Cases}
Single digit range, `low > high`, leading zeros.

\begin{lstlisting}[language=Python]
def strobogrammaticInRange(low: str, high: str) -> int:
    pairs = [('0', '0'), ('1', '1'), ('6', '9'), ('8', '8'), ('9', '6')]
    count = 0
    
    def dfs(left: str, right: str, remaining: int) -> None:
        nonlocal count
        
        if remaining == 0:
            num_str = left + right
            # Check if in range (handle leading zeros)
            if (len(num_str) == 1 or num_str[0] != '0') and \
               len(low) <= len(num_str) <= len(high) and \
               low <= num_str <= high:
                count += 1
            return
        
        for p1, p2 in pairs:
            dfs(left + p1, p2 + right, remaining - 2)
    
    # Generate numbers of each length
    for length in range(len(low), len(high) + 1):
        if length % 2 == 0:
            dfs('', '', length)
        else:
            # Odd length - middle can be 0, 1, or 8
            for mid in ['0', '1', '8']:
                dfs(mid, '', length - 1)
    
    return count
\end{lstlisting}
\textbf{Complexity:} Time $O(5^{(n/2)})$ where n = max length, Space $O(n)$

\section{Paint House II}
\subsection*{Problem Description}
Minimum cost to paint `n` houses with `k` colors, no adjacent same color.

\subsection*{Solution Approach}
\begin{itemize}
    \item Track minimum and second minimum cost for previous row.
    \item For each house, use minimum if different color.
    \item Use second minimum if same color as minimum.
    \item Update minimums for next iteration.
\end{itemize}

\subsection*{Key Algorithms}
Dynamic Programming

\subsection*{Edge Cases}
`k = 1` (impossible if `n > 1`), `n = 1`, all costs same.

\begin{lstlisting}[language=Python]
def minCostII(costs: List[List[int]]) -> int:
    if not costs or not costs[0]:
        return 0
    
    n, k = len(costs), len(costs[0])
    
    if k == 1:
        return costs[0][0] if n == 1 else -1
    
    # Track min and second min from previous house
    prev_min = prev_second_min = 0
    prev_min_color = -1
    
    for house in range(n):
        curr_min = curr_second_min = float('inf')
        curr_min_color = -1
        
        for color in range(k):
            # Cost for this color
            cost = costs[house][color]
            if color == prev_min_color:
                cost += prev_second_min
            else:
                cost += prev_min
            
            # Update current minimums
            if cost < curr_min:
                curr_second_min = curr_min
                curr_min = cost
                curr_min_color = color
            elif cost < curr_second_min:
                curr_second_min = cost
        
        prev_min = curr_min
        prev_second_min = curr_second_min
        prev_min_color = curr_min_color
    
    return prev_min
\end{lstlisting}
\textbf{Complexity:} Time $O(nk)$, Space $O(1)$

\section{Alien Dictionary}
\subsection*{Problem Description}
Derive lexicographic order from sorted alien words.

\subsection*{Solution Approach}
\begin{itemize}
    \item Build graph from adjacent word comparisons.
    \item Find first differing character pairs.
    \item Topological sort using DFS.
    \item Detect cycles (invalid order).
\end{itemize}

\subsection*{Key Algorithms}
Topological Sort, Graph

\subsection*{Edge Cases}
Invalid order, prefix relationships, single word.

\begin{lstlisting}[language=Python]
from collections import defaultdict, deque

def alienOrder(words: List[str]) -> str:
    # Build adjacency list
    adj = defaultdict(set)
    in_degree = {c: 0 for word in words for c in word}
    
    # Compare adjacent words
    for i in range(len(words) - 1):
        w1, w2 = words[i], words[i + 1]
        min_len = min(len(w1), len(w2))
        
        # Check if w2 is prefix of w1 (invalid)
        if len(w1) > len(w2) and w1[:min_len] == w2:
            return ""
        
        # Find first different character
        for j in range(min_len):
            if w1[j] != w2[j]:
                if w2[j] not in adj[w1[j]]:
                    adj[w1[j]].add(w2[j])
                    in_degree[w2[j]] += 1
                break
    
    # Topological sort using BFS
    queue = deque([c for c in in_degree if in_degree[c] == 0])
    result = []
    
    while queue:
        char = queue.popleft()
        result.append(char)
        
        for neighbor in adj[char]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)
    
    # Check if all characters are included (no cycle)
    return ''.join(result) if len(result) == len(in_degree) else ""
\end{lstlisting}
\textbf{Complexity:} Time $O(\text{total chars})$, Space $O(1)$ since at most 26 letters

\section{Closest Binary Search Tree Value II}
\subsection*{Problem Description}
Find `k` values in BST closest to `target`.

\subsection*{Solution Approach}
\begin{itemize}
    \item Inorder traversal to get sorted values.
    \item Use two pointers or binary search to find closest.
    \item Expand window to get `k` values.
    \item Alternative: Use heap during traversal.
\end{itemize}

\subsection*{Key Algorithms}
BST Traversal, Two Pointers

\subsection*{Edge Cases}
`k` equals tree size, `target` outside tree range.

\begin{lstlisting}[language=Python]
def closestKValues(root: Optional[TreeNode], target: float, k: int) -> List[int]:
    # Inorder traversal to get sorted values
    values = []
    
    def inorder(node: Optional[TreeNode]) -> None:
        if not node:
            return
        inorder(node.left)
        values.append(node.val)
        inorder(node.right)
    
    inorder(root)
    
    # Find closest value using binary search
    left = 0
    right = len(values) - 1
    
    while right - left + 1 > k:
        if abs(values[left] - target) > abs(values[right] - target):
            left += 1
        else:
            right -= 1
    
    return values[left:right + 1]
\end{lstlisting}
\textbf{Complexity:} Time $O(n)$, Space $O(n)$

\section{Integer to English Words}
\subsection*{Problem Description}
Convert integer to English words representation.

\subsection*{Solution Approach}
\begin{itemize}
    \item Handle groups of three digits.
    \item Process billions, millions, thousands, hundreds.
    \item Special cases for 0-19 and tens.
    \item Combine parts with proper spacing.
\end{itemize}

\subsection*{Key Algorithms}
String Manipulation

\subsection*{Edge Cases}
0, powers of 10, teens, exact thousands/millions.

\begin{lstlisting}[language=Python]
def numberToWords(num: int) -> str:
    if num == 0:
        return "Zero"
    
    # Define mappings
    ones = ["", "One", "Two", "Three", "Four", "Five", "Six", "Seven", 
            "Eight", "Nine", "Ten", "Eleven", "Twelve", "Thirteen", 
            "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen"]
    tens = ["", "", "Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"]
    thousands = ["", "Thousand", "Million", "Billion"]
    
    def helper(num: int) -> str:
        if num == 0:
            return ""
        elif num < 20:
            return ones[num]
        elif num < 100:
            return tens[num // 10] + (" " + ones[num % 10] if num % 10 else "")
        else:
            return ones[num // 100] + " Hundred" + (" " + helper(num % 100) if num % 100 else "")
    
    result = []
    group_index = 0
    
    while num > 0:
        if num % 1000 != 0:
            group_words = helper(num % 1000)
            if thousands[group_index]:
                group_words += " " + thousands[group_index]
            result.append(group_words)
        num //= 1000
        group_index += 1
    
    return " ".join(reversed(result))
\end{lstlisting}
\textbf{Complexity:} Time $O(1)$, Space $O(1)$

\section{Expression Add Operators}
\subsection*{Problem Description}
Add operators `(+, -, *)` to digits to get target value.

\subsection*{Solution Approach}
\begin{itemize}
    \item Backtracking with current expression and value.
    \item Track previous operand for multiplication.
    \item Try splitting at each position.
    \item Handle leading zeros.
\end{itemize}

\subsection*{Key Algorithms}
Backtracking

\subsection*{Edge Cases}
Leading zeros, overflow, single digit.

\begin{lstlisting}[language=Python]
def addOperators(num: str, target: int) -> List[str]:
    result = []
    
    def backtrack(index: int, path: str, value: int, prev: int) -> None:
        if index == len(num):
            if value == target:
                result.append(path)
            return
        
        for i in range(index, len(num)):
            # Skip numbers with leading zeros
            if i > index and num[index] == '0':
                break
            
            curr_str = num[index:i + 1]
            curr_num = int(curr_str)
            
            if index == 0:
                # First number
                backtrack(i + 1, curr_str, curr_num, curr_num)
            else:
                # Addition
                backtrack(i + 1, path + '+' + curr_str, value + curr_num, curr_num)
                
                # Subtraction
                backtrack(i + 1, path + '-' + curr_str, value - curr_num, -curr_num)
                
                # Multiplication
                backtrack(i + 1, path + '*' + curr_str, 
                         value - prev + prev * curr_num, prev * curr_num)
    
    backtrack(0, "", 0, 0)
    return result
\end{lstlisting}
\textbf{Complexity:} Time $O(4^n)$, Space $O(n)$

\section{Find Median from Data Stream}
\subsection*{Problem Description}
Find median after each number insertion.

\subsection*{Solution Approach}
\begin{itemize}
    \item Use two heaps: max heap for smaller half, min heap for larger.
    \item Balance heaps to differ by at most 1.
    \item Median is top of larger heap or average of tops.
    \item Always insert to max heap first.
\end{itemize}

\subsection*{Key Algorithms}
Two Heaps

\subsection*{Edge Cases}
Single element, even/odd count.

\begin{lstlisting}[language=Python]
import heapq

class MedianFinder:
    def __init__(self):
        self.small = []  # Max heap (negate values)
        self.large = []  # Min heap
    
    def addNum(self, num: int) -> None:
        # Add to max heap
        heapq.heappush(self.small, -num)
        
        # Balance: move largest from small to large
        heapq.heappush(self.large, -heapq.heappop(self.small))
        
        # Ensure size property
        if len(self.large) > len(self.small):
            heapq.heappush(self.small, -heapq.heappop(self.large))
    
    def findMedian(self) -> float:
        if len(self.small) > len(self.large):
            return -self.small[0]
        else:
            return (-self.small[0] + self.large[0]) / 2
\end{lstlisting}
\textbf{Complexity:} Time $O(\log n)$ insert, $O(1)$ find, Space $O(n)$

\section{Best Meeting Point}
\subsection*{Problem Description}
Find point minimizing total Manhattan distance for all people.

\subsection*{Solution Approach}
\begin{itemize}
    \item Median minimizes sum of absolute deviations.
    \item Find median of x-coordinates and y-coordinates separately.
    \item Meeting point is \texttt{(median\_x, median\_y)}.
    \item Calculate total distance.
\end{itemize}

\subsection*{Key Algorithms}
Math, Median

\subsection*{Edge Cases}
Single person, all in line, grid boundaries.

\begin{lstlisting}[language=Python]
def minTotalDistance(grid: List[List[int]]) -> int:
    rows, cols = len(grid), len(grid[0])
    
    # Collect all x and y coordinates
    x_coords = []
    y_coords = []
    
    for i in range(rows):
        for j in range(cols):
            if grid[i][j] == 1:
                x_coords.append(i)
                y_coords.append(j)
    
    # Sort coordinates
    x_coords.sort()
    y_coords.sort()
    
    # Find medians
    median_x = x_coords[len(x_coords) // 2]
    median_y = y_coords[len(y_coords) // 2]
    
    # Calculate total distance
    distance = 0
    for x in x_coords:
        distance += abs(x - median_x)
    for y in y_coords:
        distance += abs(y - median_y)
    
    return distance
\end{lstlisting}
\textbf{Complexity:} Time $O(mn \log mn)$, Space $O(mn)$

\section{Serialize and Deserialize Binary Tree}
\subsection*{Problem Description}
Serialize binary tree to string and deserialize back.

\subsection*{Solution Approach}
\begin{itemize}
    \item Use preorder traversal for serialization.
    \item Use delimiter between values.
    \item Use special marker for null nodes.
    \item Deserialize using queue or recursion.
\end{itemize}

\subsection*{Key Algorithms}
Tree Traversal, String Parsing

\subsection*{Edge Cases}
Empty tree, single node, unbalanced tree.

\begin{lstlisting}[language=Python]
class Codec:
    def serialize(self, root: Optional[TreeNode]) -> str:
        def preorder(node: Optional[TreeNode]) -> List[str]:
            if not node:
                return ['null']
            return [str(node.val)] + preorder(node.left) + preorder(node.right)
        
        return ','.join(preorder(root))
    
    def deserialize(self, data: str) -> Optional[TreeNode]:
        values = iter(data.split(','))
        
        def build() -> Optional[TreeNode]:
            val = next(values)
            if val == 'null':
                return None
            
            node = TreeNode(int(val))
            node.left = build()
            node.right = build()
            return node
        
        return build()
\end{lstlisting}
\textbf{Complexity:} Time $O(n)$, Space $O(n)$

\section{Remove Invalid Parentheses}
\subsection*{Problem Description}
Remove minimum parentheses to make valid.

\subsection*{Solution Approach}
\begin{itemize}
    \item BFS to find minimum removals.
    \item Try removing each parenthesis.
    \item Check if valid and add to next level.
    \item Stop at first valid level.
\end{itemize}

\subsection*{Key Algorithms}
BFS

\subsection*{Edge Cases}
Already valid, no valid possible, multiple solutions.

\begin{lstlisting}[language=Python]
def removeInvalidParentheses(s: str) -> List[str]:
    def is_valid(string: str) -> bool:
        count = 0
        for char in string:
            if char == '(':
                count += 1
            elif char == ')':
                count -= 1
                if count < 0:
                    return False
        return count == 0
    
    # BFS
    level = {s}
    
    while level:
        valid = [string for string in level if is_valid(string)]
        if valid:
            return valid
        
        # Generate next level
        next_level = set()
        for string in level:
            for i in range(len(string)):
                if string[i] in '()':
                    next_level.add(string[:i] + string[i + 1:])
        
        level = next_level
    
    return [""]
\end{lstlisting}
\textbf{Complexity:} Time $O(2^n)$, Space $O(2^n)$

\section{Smallest Rectangle Enclosing Black Pixels}
\subsection*{Problem Description}
Find smallest rectangle containing all black pixels.

\subsection*{Solution Approach}
\begin{itemize}
    \item Use binary search on rows and columns.
    \item Find topmost, bottommost, leftmost, rightmost black pixels.
    \item Project to 1D and binary search.
    \item Rectangle is bounded by these coordinates.
\end{itemize}

\subsection*{Key Algorithms}
Binary Search

\subsection*{Edge Cases}
Single pixel, full grid black, scattered pixels.

\begin{lstlisting}[language=Python]
def minArea(image: List[List[str]], x: int, y: int) -> int:
    m, n = len(image), len(image[0])
    
    def search_rows(start: int, end: int, check_white: bool) -> int:
        while start < end:
            mid = (start + end) // 2
            if any(image[mid][j] == '1' for j in range(n)) == check_white:
                end = mid
            else:
                start = mid + 1
        return start
    
    def search_cols(start: int, end: int, check_white: bool) -> int:
        while start < end:
            mid = (start + end) // 2
            if any(image[i][mid] == '1' for i in range(m)) == check_white:
                end = mid
            else:
                start = mid + 1
        return start
    
    # Find boundaries
    top = search_rows(0, x, True)
    bottom = search_rows(x + 1, m, False)
    left = search_cols(0, y, True)
    right = search_cols(y + 1, n, False)
    
    return (bottom - top) * (right - left)
\end{lstlisting}
\textbf{Complexity:} Time $O((m+n) \log mn)$, Space $O(1)$

\section{Number of Islands II}
\subsection*{Problem Description}
Count islands after each land addition operation.

\subsection*{Solution Approach}
\begin{itemize}
    \item Use Union-Find data structure.
    \item For each land addition, check 4 neighbors.
    \item Union with neighboring lands.
    \item Track number of connected components.
\end{itemize}

\subsection*{Key Algorithms}
Union-Find

\subsection*{Edge Cases}
Adding same position twice, no lands, all water.

\begin{lstlisting}[language=Python]
class UnionFind:
    def __init__(self):
        self.parent = {}
        self.rank = {}
        self.count = 0
    
    def add(self, x: int) -> None:
        if x not in self.parent:
            self.parent[x] = x
            self.rank[x] = 0
            self.count += 1
    
    def find(self, x: int) -> int:
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x: int, y: int) -> None:
        px, py = self.find(x), self.find(y)
        if px == py:
            return
        
        if self.rank[px] < self.rank[py]:
            self.parent[px] = py
        elif self.rank[px] > self.rank[py]:
            self.parent[py] = px
        else:
            self.parent[py] = px
            self.rank[px] += 1
        
        self.count -= 1

def numIslands2(m: int, n: int, positions: List[List[int]]) -> List[int]:
    uf = UnionFind()
    result = []
    
    for r, c in positions:
        key = r * n + c
        
        if key in uf.parent:
            result.append(uf.count)
            continue
        
        uf.add(key)
        
        # Check 4 neighbors
        for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
            nr, nc = r + dr, c + dc
            neighbor_key = nr * n + nc
            
            if 0 <= nr < m and 0 <= nc < n and neighbor_key in uf.parent:
                uf.union(key, neighbor_key)
        
        result.append(uf.count)
    
    return result
\end{lstlisting}
\textbf{Complexity:} Time $O(k \times \alpha(mn))$ where k = operations, Space $O(k)$

\section{Burst Balloons}
\subsection*{Problem Description}
Maximum coins by bursting balloons in optimal order.

\subsection*{Solution Approach}
\begin{itemize}
    \item Dynamic programming with interval.
    \item \texttt{dp[i][j]} = max coins bursting balloons `i` to `j`.
    \item Try each balloon as last to burst in interval.
    \item Add virtual balloons with value 1 at ends.
\end{itemize}

\subsection*{Key Algorithms}
Dynamic Programming, Interval DP

\subsection*{Edge Cases}
Single balloon, all same values.

\begin{lstlisting}[language=Python]
def maxCoins(nums: List[int]) -> int:
    # Add virtual balloons
    nums = [1] + nums + [1]
    n = len(nums)
    
    # dp[i][j] = max coins bursting balloons (i, j) exclusive
    dp = [[0] * n for _ in range(n)]
    
    # Iterate by interval length
    for length in range(3, n + 1):
        for left in range(n - length + 1):
            right = left + length - 1
            
            # Try each balloon as last to burst
            for k in range(left + 1, right):
                coins = nums[left] * nums[k] * nums[right]
                coins += dp[left][k] + dp[k][right]
                dp[left][right] = max(dp[left][right], coins)
    
    return dp[0][n - 1]
\end{lstlisting}
\textbf{Complexity:} Time $O(n^3)$, Space $O(n^2)$

\section{Count of Smaller Numbers After Self}
\subsection*{Problem Description}
Count smaller elements to the right of each element.

\subsection*{Solution Approach}
\begin{itemize}
    \item Use merge sort with index tracking.
    \item During merge, count inversions.
    \item Track original indices through sorting.
    \item Alternative: Binary Indexed Tree.
\end{itemize}

\subsection*{Key Algorithms}
Merge Sort, Binary Indexed Tree

\subsection*{Edge Cases}
Sorted array, reverse sorted, duplicates.

\begin{lstlisting}[language=Python]
def countSmaller(nums: List[int]) -> List[int]:
    n = len(nums)
    result = [0] * n
    indices = list(range(n))
    
    def merge_sort(start: int, end: int) -> None:
        if end - start <= 1:
            return
        
        mid = (start + end) // 2
        merge_sort(start, mid)
        merge_sort(mid, end)
        
        # Merge and count
        temp = []
        i, j = start, mid
        
        while i < mid and j < end:
            if nums[indices[j]] < nums[indices[i]]:
                temp.append(indices[j])
                j += 1
            else:
                result[indices[i]] += j - mid
                temp.append(indices[i])
                i += 1
        
        while i < mid:
            result[indices[i]] += j - mid
            temp.append(indices[i])
            i += 1
        
        while j < end:
            temp.append(indices[j])
            j += 1
        
        indices[start:end] = temp
    
    merge_sort(0, n)
    return result
\end{lstlisting}
\textbf{Complexity:} Time $O(n \log n)$, Space $O(n)$

\section{Shortest Distance from All Buildings}
\subsection*{Problem Description}
Find best empty land to build minimizing distance to all buildings.

\subsection*{Solution Approach}
\begin{itemize}
    \item BFS from each building.
    \item Track total distance to each empty land.
    \item Track reachability count.
    \item Return minimum distance reachable by all.
\end{itemize}

\subsection*{Key Algorithms}
BFS, Grid Traversal

\subsection*{Edge Cases}
No valid location, single building, obstacles blocking.

\begin{lstlisting}[language=Python]
from collections import deque

def shortestDistance(grid: List[List[int]]) -> int:
    if not grid or not grid[0]:
        return -1
    
    m, n = len(grid), len(grid[0])
    buildings = []
    
    # Find all buildings
    for i in range(m):
        for j in range(n):
            if grid[i][j] == 1:
                buildings.append((i, j))
    
    # Distance sum and reachability count for each empty land
    dist_sum = [[0] * n for _ in range(m)]
    reach_count = [[0] * n for _ in range(m)]
    
    def bfs(start_i: int, start_j: int) -> bool:
        visited = [[False] * n for _ in range(m)]
        queue = deque([(start_i, start_j, 0)])
        visited[start_i][start_j] = True
        reached_buildings = 0
        
        while queue:
            i, j, dist = queue.popleft()
            
            for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                ni, nj = i + di, j + dj
                
                if 0 <= ni < m and 0 <= nj < n and not visited[ni][nj]:
                    visited[ni][nj] = True
                    
                    if grid[ni][nj] == 0:
                        dist_sum[ni][nj] += dist + 1
                        reach_count[ni][nj] += 1
                        queue.append((ni, nj, dist + 1))
                    elif grid[ni][nj] == 1:
                        reached_buildings += 1
        
        return reached_buildings == len(buildings) - 1
    
    # BFS from each building
    for i, j in buildings:
        if not bfs(i, j):
            return -1
    
    # Find minimum distance
    min_dist = float('inf')
    for i in range(m):
        for j in range(n):
            if grid[i][j] == 0 and reach_count[i][j] == len(buildings):
                min_dist = min(min_dist, dist_sum[i][j])
    
    return min_dist if min_dist != float('inf') else -1
\end{lstlisting}
\textbf{Complexity:} Time $O(m^2n^2)$, Space $O(mn)$

\section{Create Maximum Number}
\subsection*{Problem Description}
Create maximum number of length `k` from two arrays preserving order.

\subsection*{Solution Approach}
\begin{itemize}
    \item Try all combinations of taking `i` from `nums1`, `k-i` from `nums2`.
    \item Find maximum subsequence of given length.
    \item Merge two subsequences optimally.
    \item Compare all possibilities.
\end{itemize}

\subsection*{Key Algorithms}
Greedy, Monotonic Stack

\subsection*{Edge Cases}
`k = 0`, `k = m + n`, one array empty.

\begin{lstlisting}[language=Python]
def maxNumber(nums1: List[int], nums2: List[int], k: int) -> List[int]:
    def max_subsequence(nums: List[int], length: int) -> List[int]:
        drop = len(nums) - length
        stack = []
        
        for num in nums:
            while drop > 0 and stack and stack[-1] < num:
                stack.pop()
                drop -= 1
            stack.append(num)
        
        return stack[:length]
    
    def merge(arr1: List[int], arr2: List[int]) -> List[int]:
        result = []
        i = j = 0
        
        while i < len(arr1) or j < len(arr2):
            if i < len(arr1) and (j >= len(arr2) or arr1[i:] > arr2[j:]):
                result.append(arr1[i])
                i += 1
            else:
                result.append(arr2[j])
                j += 1
        
        return result
    
    max_result = []
    
    for i in range(max(0, k - len(nums2)), min(k, len(nums1)) + 1):
        sub1 = max_subsequence(nums1, i)
        sub2 = max_subsequence(nums2, k - i)
        merged = merge(sub1, sub2)
        max_result = max(max_result, merged)
    
    return max_result
\end{lstlisting}
\textbf{Complexity:} Time $O(k \times (m + n + k))$, Space $O(k)$

\section{Count of Range Sum}
\subsection*{Problem Description}
Count ranges where sum is in `[lower, upper]`.

\subsection*{Solution Approach}
\begin{itemize}
    \item Use merge sort to count during merge.
    \item Convert to prefix sum problem.
    \item Count pairs where \texttt{lower <= prefix[j] - prefix[i] <= upper}.
    \item Use merge sort to efficiently count.
\end{itemize}

\subsection*{Key Algorithms}
Merge Sort, Prefix Sum

\subsection*{Edge Cases}
Single element, all negative, empty range.

\begin{lstlisting}[language=Python]
def countRangeSum(nums: List[int], lower: int, upper: int) -> int:
    # Compute prefix sums
    prefix = [0]
    for num in nums:
        prefix.append(prefix[-1] + num)
    
    def merge_sort(start: int, end: int) -> int:
        if end - start <= 1:
            return 0
        
        mid = (start + end) // 2
        count = merge_sort(start, mid) + merge_sort(mid, end)
        
        # Count valid ranges crossing mid
        j = k = mid
        for i in range(start, mid):
            while j < end and prefix[j] - prefix[i] < lower:
                j += 1
            while k < end and prefix[k] - prefix[i] <= upper:
                k += 1
            count += k - j
        
        # Merge sorted halves
        temp = []
        i, j = start, mid
        while i < mid and j < end:
            if prefix[i] <= prefix[j]:
                temp.append(prefix[i])
                i += 1
            else:
                temp.append(prefix[j])
                j += 1
        
        temp.extend(prefix[i:mid])
        temp.extend(prefix[j:end])
        prefix[start:end] = temp
        
        return count
    
    return merge_sort(0, len(prefix))
\end{lstlisting}
\textbf{Complexity:} Time $O(n \log n)$, Space $O(n)$

\section{Longest Increasing Path in a Matrix}
\subsection*{Problem Description}
Find longest increasing path in matrix.

\subsection*{Solution Approach}
\begin{itemize}
    \item DFS with memoization from each cell.
    \item Explore 4 directions with increasing values.
    \item Cache results to avoid recomputation.
    \item Return maximum among all starting points.
\end{itemize}

\subsection*{Key Algorithms}
DFS, Memoization

\subsection*{Edge Cases}
Single cell, all same values, strictly increasing.

\begin{lstlisting}[language=Python]
def longestIncreasingPath(matrix: List[List[int]]) -> int:
    if not matrix or not matrix[0]:
        return 0
    
    m, n = len(matrix), len(matrix[0])
    memo = {}
    
    def dfs(i: int, j: int) -> int:
        if (i, j) in memo:
            return memo[(i, j)]
        
        max_path = 1
        
        for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
            ni, nj = i + di, j + dj
            
            if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > matrix[i][j]:
                max_path = max(max_path, 1 + dfs(ni, nj))
        
        memo[(i, j)] = max_path
        return max_path
    
    return max(dfs(i, j) for i in range(m) for j in range(n))
\end{lstlisting}
\textbf{Complexity:} Time $O(mn)$, Space $O(mn)$

\section{Patching Array}
\subsection*{Problem Description}
Minimum patches to array so sums cover `[1, n]`.

\subsection*{Solution Approach}
\begin{itemize}
    \item Track maximum reachable number.
    \item If can't reach next number, add it as patch.
    \item When adding number `x`, extend range by `x`.
    \item Continue until reach `n`.
\end{itemize}

\subsection*{Key Algorithms}
Greedy

\subsection*{Edge Cases}
Empty array, `n = 1`, array already covers range.

\begin{lstlisting}[language=Python]
def minPatches(nums: List[int], n: int) -> int:
    patches = 0
    i = 0
    miss = 1  # Smallest number we can't form
    
    while miss <= n:
        if i < len(nums) and nums[i] <= miss:
            # Can use nums[i] to extend range
            miss += nums[i]
            i += 1
        else:
            # Need to patch with 'miss'
            miss += miss
            patches += 1
    
    return patches
\end{lstlisting}
\textbf{Complexity:} Time $O(m + \log n)$ where m = len(nums), Space $O(1)$

\section{Reconstruct Itinerary}
\subsection*{Problem Description}
Find itinerary visiting all tickets exactly once, lexicographically smallest.

\subsection*{Solution Approach}
\begin{itemize}
    \item Build adjacency list with sorted destinations.
    \item Use DFS with backtracking.
    \item Use tickets in order, mark as used.
    \item Hierholzer's algorithm for Eulerian path.
\end{itemize}

\subsection*{Key Algorithms}
DFS, Eulerian Path

\subsection*{Edge Cases}
Multiple valid paths, cycles, dead ends.

\begin{lstlisting}[language=Python]
from collections import defaultdict

def findItinerary(tickets: List[List[str]]) -> List[str]:
    # Build graph
    graph = defaultdict(list)
    for src, dst in sorted(tickets, reverse=True):
        graph[src].append(dst)
    
    result = []
    
    def dfs(airport: str) -> None:
        while graph[airport]:
            next_airport = graph[airport].pop()
            dfs(next_airport)
        result.append(airport)
    
    dfs("JFK")
    return result[::-1]
\end{lstlisting}
\textbf{Complexity:} Time $O(E \log E)$ where E = edges, Space $O(E)$

\section{Self Crossing}
\subsection*{Problem Description}
Check if path crosses itself.

\subsection*{Solution Approach}
\begin{itemize}
    \item Check if current line crosses any of last 3-5 lines.
    \item Line `i` can only cross lines `i-3`, `i-4`, or `i-5`.
    \item Check intersection conditions for each case.
    \item Use geometric conditions.
\end{itemize}

\subsection*{Key Algorithms}
Geometry, Line Intersection

\subsection*{Edge Cases}
Less than 4 moves, spiral patterns.

\begin{lstlisting}[language=Python]
def isSelfCrossing(distance: List[int]) -> bool:
    n = len(distance)
    
    for i in range(3, n):
        # Fourth line crosses first line
        if i >= 3:
            if distance[i] >= distance[i-2] and distance[i-1] <= distance[i-3]:
                return True
        
        # Fifth line crosses second line
        if i >= 4:
            if distance[i-1] == distance[i-3] and \
               distance[i] + distance[i-4] >= distance[i-2]:
                return True
        
        # Sixth line crosses third line
        if i >= 5:
            if distance[i-2] >= distance[i-4] and \
               distance[i] + distance[i-4] >= distance[i-2] and \
               distance[i-1] + distance[i-5] >= distance[i-3] and \
               distance[i-3] >= distance[i-1]:
                return True
    
    return False
\end{lstlisting}
\textbf{Complexity:} Time $O(n)$, Space $O(1)$

\section{Palindrome Pairs}
\subsection*{Problem Description}
Find pairs of words that form palindromes when concatenated.

\subsection*{Solution Approach}
\begin{itemize}
    \item Use Trie or HashMap for efficient lookup.
    \item For each word, check if reverse exists.
    \item Check partial matches for different lengths.
    \item Handle empty strings and self-palindromes.
\end{itemize}

\subsection*{Key Algorithms}
Trie, String Matching

\subsection*{Edge Cases}
Empty strings, single character, self-palindromes.

\begin{lstlisting}[language=Python]
def palindromePairs(words: List[str]) -> List[List[int]]:
    word_dict = {word: i for i, word in enumerate(words)}
    result = []
    
    for i, word in enumerate(words):
        # Check all possible splits
        for j in range(len(word) + 1):
            prefix = word[:j]
            suffix = word[j:]
            
            # If prefix is palindrome, check if reverse suffix exists
            if prefix == prefix[::-1]:
                rev_suffix = suffix[::-1]
                if rev_suffix in word_dict and word_dict[rev_suffix] != i:
                    result.append([word_dict[rev_suffix], i])
            
            # If suffix is palindrome, check if reverse prefix exists
            if j > 0 and suffix == suffix[::-1]:
                rev_prefix = prefix[::-1]
                if rev_prefix in word_dict and word_dict[rev_prefix] != i:
                    result.append([i, word_dict[rev_prefix]])
    
    return result
\end{lstlisting}
\textbf{Complexity:} Time $O(n \times k^2)$ where k = average word length, Space $O(nk)$

\section{Data Stream as Disjoint Intervals}
\subsection*{Problem Description}
Maintain disjoint intervals from data stream.

\subsection*{Solution Approach}
\begin{itemize}
    \item Use TreeMap/SortedList to maintain intervals.
    \item When adding number, check adjacent intervals.
    \item Merge if necessary.
    \item Handle three cases: extend left, extend right, bridge gap.
\end{itemize}

\subsection*{Key Algorithms}
Interval Merging, Binary Search

\subsection*{Edge Cases}
Duplicate values, single point intervals.

\begin{lstlisting}[language=Python]
from sortedcontainers import SortedList

class SummaryRanges:
    def __init__(self):
        self.intervals = SortedList()
    
    def addNum(self, value: int) -> None:
        # Find position to insert
        idx = self.intervals.bisect_left([value, value])
        
        # Check if can merge with previous interval
        if idx > 0 and self.intervals[idx - 1][1] >= value - 1:
            self.intervals[idx - 1][1] = max(self.intervals[idx - 1][1], value)
            # Check if can merge with next interval
            if idx < len(self.intervals) and self.intervals[idx][0] <= value + 1:
                self.intervals[idx - 1][1] = max(self.intervals[idx - 1][1], 
                                                 self.intervals[idx][1])
                self.intervals.pop(idx)
        # Check if can merge with next interval
        elif idx < len(self.intervals) and self.intervals[idx][0] <= value + 1:
            self.intervals[idx][0] = min(self.intervals[idx][0], value)
        else:
            # Create new interval
            self.intervals.add([value, value])
    
    def getIntervals(self) -> List[List[int]]:
        return list(self.intervals)
\end{lstlisting}
\textbf{Complexity:} Time $O(\log n)$ per add, Space $O(n)$

\section{Russian Doll Envelopes}
\subsection*{Problem Description}
Maximum envelopes that can be nested (by width and height).

\subsection*{Solution Approach}
\begin{itemize}
    \item Sort by width ascending, height descending.
    \item Find LIS on heights.
    \item Height descending ensures same width won't nest.
    \item Use binary search for $O(n \log n)$ LIS.
\end{itemize}

\subsection*{Key Algorithms}
LIS, Binary Search

\subsection*{Edge Cases}
Same dimensions, single envelope, all same width/height.

\begin{lstlisting}[language=Python]
from bisect import bisect_left

def maxEnvelopes(envelopes: List[List[int]]) -> int:
    # Sort by width ascending, height descending
    envelopes.sort(key=lambda x: (x[0], -x[1]))
    
    # Find LIS on heights
    dp = []
    
    for _, height in envelopes:
        idx = bisect_left(dp, height)
        if idx == len(dp):
            dp.append(height)
        else:
            dp[idx] = height
    
    return len(dp)
\end{lstlisting}
\textbf{Complexity:} Time $O(n \log n)$, Space $O(n)$

\section{Rearrange String k Distance Apart}
\subsection*{Problem Description}
Rearrange string so same characters are at least `k` distance apart.

\subsection*{Solution Approach}
\begin{itemize}
    \item Count character frequencies.
    \item Use max heap to get most frequent.
    \item Use queue to track cooling characters.
    \item Greedily place characters.
\end{itemize}

\subsection*{Key Algorithms}
Heap, Greedy

\subsection*{Edge Cases}
`k = 0`, `k >` string length, impossible arrangement.

\begin{lstlisting}[language=Python]
from collections import Counter
import heapq

def rearrangeString(s: str, k: int) -> str:
    if k <= 1:
        return s
    
    # Count frequencies
    freq = Counter(s)
    
    # Max heap of (-frequency, char)
    heap = [(-count, char) for char, count in freq.items()]
    heapq.heapify(heap)
    
    result = []
    queue = deque()  # Characters in cooling period
    
    while heap or queue:
        # Move cooled characters back to heap
        if len(result) >= k and queue:
            count, char = queue.popleft()
            if count < 0:
                heapq.heappush(heap, (count, char))
        
        if not heap:
            return ""  # No valid arrangement
        
        # Use most frequent character
        count, char = heapq.heappop(heap)
        result.append(char)
        
        # Add to cooling queue if more instances remain
        if count < -1:
            queue.append((count + 1, char))
    
    return ''.join(result)
\end{lstlisting}
\textbf{Complexity:} Time $O(n \log 26) = O(n)$, Space $O(26) = O(1)$

\section{Max Sum of Rectangle No Larger Than K}
\subsection*{Problem Description}
Find maximum sum rectangle with sum $\le k$.

\subsection*{Solution Approach}
\begin{itemize}
    \item Fix left and right columns.
    \item Use Kadane's algorithm variant with constraint.
    \item Use TreeSet/SortedList to find best prefix.
    \item Binary search for prefix sum.
\end{itemize}

\subsection*{Key Algorithms}
Kadane's Algorithm, Binary Search

\subsection*{Edge Cases}
All negative, `k <` all elements, single element = `k`.

\begin{lstlisting}[language=Python]
from sortedcontainers import SortedList

def maxSumSubmatrix(matrix: List[List[int]], k: int) -> int:
    m, n = len(matrix), len(matrix[0])
    max_sum = float('-inf')
    
    # Try all left boundaries
    for left in range(n):
        # Row sums for current left-right range
        row_sums = [0] * m
        
        # Try all right boundaries
        for right in range(left, n):
            # Update row sums
            for i in range(m):
                row_sums[i] += matrix[i][right]
            
            # Find max subarray sum <= k
            sorted_sums = SortedList([0])
            curr_sum = 0
            
            for row_sum in row_sums:
                curr_sum += row_sum
                # Find smallest prefix sum >= curr_sum - k
                idx = sorted_sums.bisect_left(curr_sum - k)
                if idx < len(sorted_sums):
                    max_sum = max(max_sum, curr_sum - sorted_sums[idx])
                sorted_sums.add(curr_sum)
    
    return max_sum
\end{lstlisting}
\textbf{Complexity:} Time $O(n^2 \times m \log m)$, Space $O(m)$

\section{Insert Delete GetRandom O(1) - Duplicates allowed}
\subsection*{Problem Description}
Data structure supporting insert, remove, getRandom with duplicates.

\subsection*{Solution Approach}
\begin{itemize}
    \item Use array for random access.
    \item HashMap maps value to set of indices.
    \item For remove, swap with last element.
    \item Update indices after swap.
\end{itemize}

\subsection*{Key Algorithms}
Hash Map, Array

\subsection*{Edge Cases}
Remove non-existent, single element, all duplicates.

\begin{lstlisting}[language=Python]
import random
from collections import defaultdict

class RandomizedCollection:
    def __init__(self):
        self.nums = []
        self.indices = defaultdict(set)
    
    def insert(self, val: int) -> bool:
        self.indices[val].add(len(self.nums))
        self.nums.append(val)
        return len(self.indices[val]) == 1
    
    def remove(self, val: int) -> bool:
        if not self.indices[val]:
            return False
        
        # Get index to remove
        remove_idx = self.indices[val].pop()
        last_val = self.nums[-1]
        
        # Swap with last element
        self.nums[remove_idx] = last_val
        
        # Update indices
        if self.indices[last_val]:
            self.indices[last_val].add(remove_idx)
            self.indices[last_val].discard(len(self.nums) - 1)
        
        self.nums.pop()
        return True
    
    def getRandom(self) -> int:
        return random.choice(self.nums)
\end{lstlisting}
\textbf{Complexity:} Time $O(1)$ all operations, Space $O(n)$

\section{Perfect Rectangle}
\subsection*{Problem Description}
Check if rectangles form perfect rectangle without overlap.

\subsection*{Solution Approach}
\begin{itemize}
    \item Track corner points - should appear even times except 4.
    \item Sum areas should equal bounding rectangle.
    \item Use set to track corners with odd count.
    \item Check final corners form rectangle.
\end{itemize}

\subsection*{Key Algorithms}
Hash Set, Geometry

\subsection*{Edge Cases}
Single rectangle, gaps, overlaps.

\begin{lstlisting}[language=Python]
def isRectangleCover(rectangles: List[List[int]]) -> bool:
    corners = set()
    area = 0
    
    min_x = min_y = float('inf')
    max_x = max_y = float('-inf')
    
    for x1, y1, x2, y2 in rectangles:
        # Update bounding box
        min_x = min(min_x, x1)
        min_y = min(min_y, y1)
        max_x = max(max_x, x2)
        max_y = max(max_y, y2)
        
        # Add area
        area += (x2 - x1) * (y2 - y1)
        
        # Toggle corners
        for x, y in [(x1, y1), (x1, y2), (x2, y1), (x2, y2)]:
            if (x, y) in corners:
                corners.remove((x, y))
            else:
                corners.add((x, y))
    
    # Check area matches
    if area != (max_x - min_x) * (max_y - min_y):
        return False
    
    # Check exactly 4 corners remain
    expected = {(min_x, min_y), (min_x, max_y), (max_x, min_y), (max_x, max_y)}
    return corners == expected
\end{lstlisting}
\textbf{Complexity:} Time $O(n)$, Space $O(n)$

\section{Frog Jump}
\subsection*{Problem Description}
Can frog cross river jumping on stones with constraints.

\subsection*{Solution Approach}
\begin{itemize}
    \item Dynamic programming with states \texttt{(stone, last\_jump)}.
    \item From each stone, try jumps of \texttt{k-1, k, k+1}.
    \item Use memoization to avoid recomputation.
    \item Check if can reach last stone.
\end{itemize}

\subsection*{Key Algorithms}
Dynamic Programming, Memoization

\subsection*{Edge Cases}
No valid path, first jump must be 1, gaps too large.

\begin{lstlisting}[language=Python]
def canCross(stones: List[int]) -> bool:
    stone_set = set(stones)
    memo = {}
    
    def dfs(pos: int, jump: int) -> bool:
        if pos == stones[-1]:
            return True
        
        if (pos, jump) in memo:
            return memo[(pos, jump)]
        
        # Try jumps of k-1, k, k+1
        for next_jump in [jump - 1, jump, jump + 1]:
            if next_jump > 0 and pos + next_jump in stone_set:
                if dfs(pos + next_jump, next_jump):
                    memo[(pos, jump)] = True
                    return True
        
        memo[(pos, jump)] = False
        return False
    
    # First jump must be 1
    return stones[1] == 1 and dfs(1, 1)
\end{lstlisting}
\textbf{Complexity:} Time $O(n^2)$, Space $O(n^2)$

\section{Trapping Rain Water II}
\subsection*{Problem Description}
Trap rainwater in 2D elevation map.

\subsection*{Solution Approach}
\begin{itemize}
    \item Use min heap starting from boundaries.
    \item Process cells from lowest to highest.
    \item Water level determined by minimum boundary.
    \item Update neighbors and add to heap.
\end{itemize}

\subsection*{Key Algorithms}
Priority Queue, BFS

\subsection*{Edge Cases}
No water trapped, bowl shape, single cell.

\begin{lstlisting}[language=Python]
import heapq

def trapRainWater(heightMap: List[List[int]]) -> int:
    if not heightMap or not heightMap[0]:
        return 0
    
    m, n = len(heightMap), len(heightMap[0])
    visited = [[False] * n for _ in range(m)]
    heap = []
    
    # Add boundary cells to heap
    for i in range(m):
        for j in range(n):
            if i == 0 or i == m - 1 or j == 0 or j == n - 1:
                heapq.heappush(heap, (heightMap[i][j], i, j))
                visited[i][j] = True
    
    water = 0
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    
    while heap:
        height, x, y = heapq.heappop(heap)
        
        # Check neighbors
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            
            if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]:
                visited[nx][ny] = True
                # Water trapped is difference from current level
                water += max(0, height - heightMap[nx][ny])
                # Add neighbor with updated height
                heapq.heappush(heap, (max(height, heightMap[nx][ny]), nx, ny))
    
    return water
\end{lstlisting}
\textbf{Complexity:} Time $O(mn \log(mn))$, Space $O(mn)$

\section{Split Array Largest Sum}
\subsection*{Problem Description}
Split array into `k` subarrays minimizing largest sum.

\subsection*{Solution Approach}
\begin{itemize}
    \item Binary search on the answer.
    \item For each candidate sum, check if possible with `k` splits.
    \item Greedily assign elements to subarrays.
    \item Adjust search range based on feasibility.
\end{itemize}

\subsection*{Key Algorithms}
Binary Search, Greedy

\subsection*{Edge Cases}
`k = 1`, `k = n`, all same values.

\begin{lstlisting}[language=Python]
def splitArray(nums: List[int], k: int) -> int:
    def can_split(max_sum: int) -> bool:
        count = 1
        current_sum = 0
        
        for num in nums:
            if current_sum + num > max_sum:
                count += 1
                current_sum = num
                if count > k:
                    return False
            else:
                current_sum += num
        
        return True
    
    # Binary search range
    left = max(nums)
    right = sum(nums)
    
    while left < right:
        mid = (left + right) // 2
        if can_split(mid):
            right = mid
        else:
            left = mid + 1
    
    return left
\end{lstlisting}
\textbf{Complexity:} Time $O(n \log(\text{sum}))$, Space $O(1)$

\section{Minimum Unique Word Abbreviation}
\subsection*{Problem Description}
Find shortest abbreviation of `target` unique among `dictionary`.

\subsection*{Solution Approach}
\begin{itemize}
    \item Generate all possible abbreviations.
    \item Use bit manipulation for abbreviation patterns.
    \item Check uniqueness against dictionary.
    \item Return shortest unique abbreviation.
\end{itemize}

\subsection*{Key Algorithms}
Bit Manipulation, BFS

\subsection*{Edge Cases}
No abbreviation needed, single character, all words same length.

\begin{lstlisting}[language=Python]
def minAbbreviation(target: str, dictionary: List[str]) -> str:
    m = len(target)
    diffs = []
    
    # Pre-calculate difference masks
    for word in dictionary:
        if len(word) == m:
            diff = 0
            for i in range(m):
                if target[i] != word[i]:
                    diff |= 1 << i
            if diff == 0:  # Same word in dictionary
                return ""
            diffs.append(diff)
    
    if not diffs:
        return str(m)
    
    # Try abbreviations by length
    for length in range(m + 1):
        for cand in range(1 << m):
            if bin(cand).count('1') != length:
                continue
            
            # Check if valid abbreviation
            if all(cand & diff for diff in diffs):
                # Build abbreviation string
                result = []
                count = 0
                for i in range(m):
                    if cand & (1 << i):
                        if count:
                            result.append(str(count))
                            count = 0
                        result.append(target[i])
                    else:
                        count += 1
                if count:
                    result.append(str(count))
                return ''.join(result)
    
    return ""
\end{lstlisting}
\textbf{Complexity:} Time $O(2^m \times n)$, Space $O(n)$

\section{Word Squares}
\subsection*{Problem Description}
Find all word squares from given words.

\subsection*{Solution Approach}
\begin{itemize}
    \item Build prefix map for quick lookup.
    \item Use backtracking to build squares.
    \item For row `i`, prefix is column `i` of previous rows.
    \item Ensure symmetric property maintained.
\end{itemize}

\subsection*{Key Algorithms}
Backtracking, Trie/HashMap

\subsection*{Edge Cases}
No valid squares, single letter words, all same word.

\begin{lstlisting}[language=Python]
from collections import defaultdict

def wordSquares(words: List[str]) -> List[List[str]]:
    n = len(words[0])
    prefix_map = defaultdict(list)
    
    # Build prefix map
    for word in words:
        for i in range(n):
            prefix_map[word[:i]].append(word)
    
    result = []
    
    def backtrack(square: List[str]) -> None:
        pos = len(square)
        if pos == n:
            result.append(square[:])
            return
        
        # Get required prefix for next word
        prefix = ''.join(square[i][pos] for i in range(pos))
        
        # Try all words with this prefix
        for word in prefix_map[prefix]:
            square.append(word)
            backtrack(square)
            square.pop()
    
    # Try each word as first word
    for word in words:
        backtrack([word])
    
    return result
\end{lstlisting}
\textbf{Complexity:} Time $O(N \times 26^L)$ where N = words, L = length, Space $O(NL)$

\section{Serialize and Deserialize N-ary Tree}
\subsection*{Problem Description}
Serialize/deserialize N-ary tree.

\subsection*{Solution Approach}
\begin{itemize}
    \item Use preorder traversal with child count.
    \item Format: \texttt{value,child\_count,children...}
    \item Recursively serialize each node.
    \item Deserialize by reading count and recursing.
\end{itemize}

\subsection*{Key Algorithms}
Tree Traversal, Recursion

\subsection*{Edge Cases}
Empty tree, single node, many children.

\begin{lstlisting}[language=Python]
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children else []

class Codec:
    def serialize(self, root: Optional[Node]) -> str:
        if not root:
            return ""
        
        def preorder(node: Node) -> List[str]:
            result = [str(node.val), str(len(node.children))]
            for child in node.children:
                result.extend(preorder(child))
            return result
        
        return ','.join(preorder(root))
    
    def deserialize(self, data: str) -> Optional[Node]:
        if not data:
            return None
        
        values = iter(data.split(','))
        
        def build() -> Node:
            val = int(next(values))
            child_count = int(next(values))
            
            node = Node(val)
            for _ in range(child_count):
                node.children.append(build())
            
            return node
        
        return build()
\end{lstlisting}
\textbf{Complexity:} Time $O(n)$, Space $O(n)$

\section{Encode N-ary Tree to Binary Tree}
\subsection*{Problem Description}
Convert N-ary tree to binary tree and back.

\subsection*{Solution Approach}
\begin{itemize}
    \item First child becomes left child in binary.
    \item Siblings become right children chain.
    \item Decode reverses this process.
    \item Maintain parent-child relationships.
\end{itemize}

\subsection*{Key Algorithms}
Tree Transformation

\subsection*{Edge Cases}
Empty tree, single child, many children.

\begin{lstlisting}[language=Python]
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Codec:
    def encode(self, root: Optional[Node]) -> Optional[TreeNode]:
        if not root:
            return None
        
        binary_root = TreeNode(root.val)
        
        if root.children:
            # First child becomes left child
            binary_root.left = self.encode(root.children[0])
            
            # Remaining children form right chain
            current = binary_root.left
            for i in range(1, len(root.children)):
                current.right = self.encode(root.children[i])
                current = current.right
        
        return binary_root
    
    def decode(self, root: Optional[TreeNode]) -> Optional[Node]:
        if not root:
            return None
        
        n_ary_root = Node(root.val)
        
        # Traverse right chain to collect children
        current = root.left
        while current:
            n_ary_root.children.append(self.decode(current))
            current = current.right
        
        return n_ary_root
\end{lstlisting}
\textbf{Complexity:} Time $O(n)$, Space $O(h)$ where h = height

\section{All O` one Data Structure}
\subsection*{Problem Description}
Data structure with `inc`, `dec`, `getMaxKey`, `getMinKey` all $O(1)$.

\subsection*{Solution Approach}
\begin{itemize}
    \item Use doubly linked list of buckets (count -> keys).
    \item HashMap: key -> bucket node.
    \item Move keys between buckets on `inc/dec`.
    \item Head/tail for quick min/max access.
\end{itemize}

\subsection*{Key Algorithms}
Doubly Linked List, Hash Map

\subsection*{Edge Cases}
Empty structure, single key, all same count.

\begin{lstlisting}[language=Python]
class Bucket:
    def __init__(self, count: int):
        self.count = count
        self.keys = set()
        self.prev = None
        self.next = None

class AllOne:
    def __init__(self):
        self.head = Bucket(float('-inf'))
        self.tail = Bucket(float('inf'))
        self.head.next = self.tail
        self.tail.prev = self.head
        self.key_bucket = {}
    
    def _add_bucket_after(self, bucket: Bucket, count: int) -> Bucket:
        new_bucket = Bucket(count)
        new_bucket.prev = bucket
        new_bucket.next = bucket.next
        bucket.next.prev = new_bucket
        bucket.next = new_bucket
        return new_bucket
    
    def _remove_bucket(self, bucket: Bucket) -> None:
        bucket.prev.next = bucket.next
        bucket.next.prev = bucket.prev
    
    def inc(self, key: str) -> None:
        if key in self.key_bucket:
            bucket = self.key_bucket[key]
            bucket.keys.remove(key)
            
            # Find or create next bucket
            if bucket.next.count == bucket.count + 1:
                next_bucket = bucket.next
            else:
                next_bucket = self._add_bucket_after(bucket, bucket.count + 1)
            
            next_bucket.keys.add(key)
            self.key_bucket[key] = next_bucket
            
            # Remove empty bucket
            if not bucket.keys:
                self._remove_bucket(bucket)
        else:
            # New key
            if self.head.next.count == 1:
                bucket = self.head.next
            else:
                bucket = self._add_bucket_after(self.head, 1)
            
            bucket.keys.add(key)
            self.key_bucket[key] = bucket
    
    def dec(self, key: str) -> None:
        bucket = self.key_bucket[key]
        bucket.keys.remove(key)
        
        if bucket.count == 1:
            # Remove key completely
            del self.key_bucket[key]
        else:
            # Find or create previous bucket
            if bucket.prev.count == bucket.count - 1:
                prev_bucket = bucket.prev
            else:
                prev_bucket = self._add_bucket_after(bucket.prev, bucket.count - 1)
            
            prev_bucket.keys.add(key)
            self.key_bucket[key] = prev_bucket
        
        # Remove empty bucket
        if not bucket.keys:
            self._remove_bucket(bucket)
    
    def getMaxKey(self) -> str:
        if self.tail.prev == self.head:
            return ""
        return next(iter(self.tail.prev.keys))
    
    def getMinKey(self) -> str:
        if self.head.next == self.tail:
            return ""
        return next(iter(self.head.next.keys))
\end{lstlisting}
\textbf{Complexity:} Time $O(1)$ all operations, Space $O(n)$

\section{K-th Smallest in Lexicographical Order}
\subsection*{Problem Description}
Find `k`th smallest integer in lexicographical order from 1 to `n`.

\subsection*{Solution Approach}
\begin{itemize}
    \item Count numbers with each prefix.
    \item Navigate tree of numbers lexicographically.
    \item Skip subtrees when count < `k`.
    \item Drill down when needed.
\end{itemize}

\subsection*{Key Algorithms}
Tree Navigation, Counting

\subsection*{Edge Cases}
`k = 1`, `k = n`, large `n`.

\begin{lstlisting}[language=Python]
def findKthNumber(n: int, k: int) -> int:
    def count_prefix(prefix: int, n: int) -> int:
        current = prefix
        next_prefix = prefix + 1
        count = 0
        
        while current <= n:
            count += min(n + 1, next_prefix) - current
            current *= 10
            next_prefix *= 10
        
        return count
    
    current = 1
    k -= 1  # 1-indexed to 0-indexed
    
    while k > 0:
        count = count_prefix(current, n)
        
        if count <= k:
            # Skip this subtree
            k -= count
            current += 1
        else:
            # Go deeper
            current *= 10
            k -= 1
    
    return current
\end{lstlisting}
\textbf{Complexity:} Time $O(\log^2 n)$, Space $O(1)$

\section{Arithmetic Slices II - Subsequence}
\subsection*{Problem Description}
Count arithmetic subsequences of length $\ge 3$.

\subsection*{Solution Approach}
\begin{itemize}
    \item Dynamic programming with hash maps.
    \item \texttt{dp[i][diff]} = count ending at `i` with difference `diff`.
    \item For each pair, extend previous subsequences.
    \item Sum all counts $\ge 2$ length.
\end{itemize}

\subsection*{Key Algorithms}
Dynamic Programming, Hash Map

\subsection*{Edge Cases}
All same elements, no valid subsequences, overflow.

\begin{lstlisting}[language=Python]
from collections import defaultdict

def numberOfArithmeticSlices(nums: List[int]) -> int:
    n = len(nums)
    dp = [defaultdict(int) for _ in range(n)]
    total = 0
    
    for i in range(1, n):
        for j in range(i):
            diff = nums[i] - nums[j]
            
            # Subsequences ending at j with difference diff
            count = dp[j][diff]
            
            # Add to result (these form valid subsequences when extended)
            total += count
            
            # Update dp[i][diff]
            # +1 for the new 2-element subsequence [j, i]
            dp[i][diff] += count + 1
    
    return total
\end{lstlisting}
\textbf{Complexity:} Time $O(n^2)$, Space $O(n^2)$

\section{Poor Pigs}
\subsection*{Problem Description}
Minimum pigs to find poisonous bucket in given time.

\subsection*{Solution Approach}
\begin{itemize}
    \item Each pig can test \texttt{(minutesToTest/minutesToDie + 1)} states.
    \item With `d` dimensions (pigs), can test \texttt{states\^d} buckets.
    \item Find minimum pigs where \texttt{states\^pigs >= buckets}.
    \item Use logarithm to solve.
\end{itemize}

\subsection*{Key Algorithms}
Math, Information Theory

\subsection*{Edge Cases}
Only one test round, many buckets, exact power match.

\begin{lstlisting}[language=Python]
import math

def poorPigs(buckets: int, minutesToDie: int, minutesToTest: int) -> int:
    # Number of test rounds possible
    states = minutesToTest // minutesToDie + 1
    
    # Find minimum pigs where states^pigs >= buckets
    return math.ceil(math.log(buckets) / math.log(states))
\end{lstlisting}
\textbf{Complexity:} Time $O(1)$, Space $O(1)$

\section{LFU Cache}
\subsection*{Problem Description}
Implement Least Frequently Used cache with $O(1)$ operations.

\subsection*{Solution Approach}
\begin{itemize}
    \item Use frequency buckets with doubly linked lists.
    \item Hash map: key -> node.
    \item Hash map: frequency -> bucket.
    \item Track minimum frequency.
\end{itemize}

\subsection*{Key Algorithms}
Doubly Linked List, Hash Map

\subsection*{Edge Cases}
Capacity 0, single element, ties in frequency.

\begin{lstlisting}[language=Python]
class Node:
    def __init__(self, key: int = 0, value: int = 0):
        self.key = key
        self.value = value
        self.freq = 1
        self.prev = None
        self.next = None

class DLinkedList:
    def __init__(self):
        self.head = Node()
        self.tail = Node()
        self.head.next = self.tail
        self.tail.prev = self.head
        self.size = 0
    
    def add_to_head(self, node: Node) -> None:
        node.prev = self.head
        node.next = self.head.next
        self.head.next.prev = node
        self.head.next = node
        self.size += 1
    
    def remove_node(self, node: Node) -> None:
        node.prev.next = node.next
        node.next.prev = node.prev
        self.size -= 1
    
    def remove_tail(self) -> Node:
        if self.size == 0:
            return None
        tail_node = self.tail.prev
        self.remove_node(tail_node)
        return tail_node

class LFUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.min_freq = 0
        self.key_to_node = {}
        self.freq_to_list = defaultdict(DLinkedList)
    
    def get(self, key: int) -> int:
        if key not in self.key_to_node:
            return -1
        
        node = self.key_to_node[key]
        self._update_freq(node)
        return node.value
    
    def put(self, key: int, value: int) -> None:
        if self.capacity == 0:
            return
        
        if key in self.key_to_node:
            node = self.key_to_node[key]
            node.value = value
            self._update_freq(node)
        else:
            if len(self.key_to_node) >= self.capacity:
                # Remove LFU node
                min_freq_list = self.freq_to_list[self.min_freq]
                node_to_remove = min_freq_list.remove_tail()
                del self.key_to_node[node_to_remove.key]
            
            # Add new node
            new_node = Node(key, value)
            self.key_to_node[key] = new_node
            self.freq_to_list[1].add_to_head(new_node)
            self.min_freq = 1
    
    def _update_freq(self, node: Node) -> None:
        freq = node.freq
        self.freq_to_list[freq].remove_node(node)
        
        # Update min_freq if necessary
        if freq == self.min_freq and self.freq_to_list[freq].size == 0:
            self.min_freq += 1
        
        node.freq += 1
        self.freq_to_list[node.freq].add_to_head(node)
\end{lstlisting}
\textbf{Complexity:} Time $O(1)$ all operations, Space $O(\text{capacity})$

\section{Optimal Account Balancing}
\subsection*{Problem Description}
Minimum transactions to settle all debts.

\subsection*{Solution Approach}
\begin{itemize}
    \item Calculate net balance for each person.
    \item Use backtracking to try all settlement orders.
    \item Skip people with 0 balance.
    \item Optimize by settling opposite sign balances.
\end{itemize}

\subsection*{Key Algorithms}
Backtracking, Optimization

\subsection*{Edge Cases}
No debts, all balanced, circular debts.

\begin{lstlisting}[language=Python]
from collections import defaultdict

def minTransfers(transactions: List[List[int]]) -> int:
    # Calculate net balance
    balance = defaultdict(int)
    for from_person, to_person, amount in transactions:
        balance[from_person] -= amount
        balance[to_person] += amount
    
    # Get non-zero balances
    debts = [amount for amount in balance.values() if amount != 0]
    
    def dfs(start: int) -> int:
        # Skip settled debts
        while start < len(debts) and debts[start] == 0:
            start += 1
        
        if start == len(debts):
            return 0
        
        min_trans = float('inf')
        
        # Try settling with each person after start
        for i in range(start + 1, len(debts)):
            # Only settle with opposite sign
            if debts[start] * debts[i] < 0:
                # Settle debt
                debts[i] += debts[start]
                min_trans = min(min_trans, 1 + dfs(start + 1))
                # Backtrack
                debts[i] -= debts[start]
        
        return min_trans
    
    return dfs(0)
\end{lstlisting}
\textbf{Complexity:} Time $O(n!)$, Space $O(n)$

\section{Count The Repetitions}
\subsection*{Problem Description}
How many times `s2` appears as subsequence in `n1` repetitions of `s1`.

\subsection*{Solution Approach}
\begin{itemize}
    \item Find pattern cycle in matching.
    \item Track position in `s2` after each `s1`.
    \item Detect when pattern repeats.
    \item Calculate full cycles and remainder.
\end{itemize}

\subsection*{Key Algorithms}
Pattern Detection, Cycle Finding

\subsection*{Edge Cases}
No match possible, `s2` longer than repeated `s1`.

\begin{lstlisting}[language=Python]
def getMaxRepetitions(s1: str, n1: int, s2: str, n2: int) -> int:
    if n1 == 0:
        return 0
    
    # Track s2 index and count after each s1
    s1_count = 0
    s2_count = 0
    s2_idx = 0
    
    # For cycle detection
    seen = {}
    
    while s1_count < n1:
        # Process one s1
        for char in s1:
            if char == s2[s2_idx]:
                s2_idx += 1
                if s2_idx == len(s2):
                    s2_idx = 0
                    s2_count += 1
        
        s1_count += 1
        
        # Check for cycle
        if s2_idx in seen:
            # Found cycle
            prev_s1_count, prev_s2_count = seen[s2_idx]
            
            # Length of cycle
            cycle_s1 = s1_count - prev_s1_count
            cycle_s2 = s2_count - prev_s2_count
            
            # Complete cycles remaining
            remaining_cycles = (n1 - s1_count) // cycle_s1
            s2_count += remaining_cycles * cycle_s2
            s1_count += remaining_cycles * cycle_s1
            
            # Process remainder
            for _ in range(n1 - s1_count):
                for char in s1:
                    if char == s2[s2_idx]:
                        s2_idx += 1
                        if s2_idx == len(s2):
                            s2_idx = 0
                            s2_count += 1
            
            break
        
        seen[s2_idx] = (s1_count, s2_count)
    
    return s2_count // n2
\end{lstlisting}
\textbf{Complexity:} Time $O(\text{len}(s1) \times \text{len}(s2))$, Space $O(\text{len}(s2))$

\section{Encode String with Shortest Length}
\subsection*{Problem Description}
Encode string using `k[encoded]` format for shortest result.

\subsection*{Solution Approach}
\begin{itemize}
    \item Dynamic programming with substring encoding.
    \item Try all possible splits.
    \item Check if substring can be compressed.
    \item Memoize optimal encodings.
\end{itemize}

\subsection*{Key Algorithms}
Dynamic Programming, String Compression

\subsection*{Edge Cases}
No compression possible, nested patterns.

\begin{lstlisting}[language=Python]
def encode(s: str) -> str:
    n = len(s)
    dp = [[''] * n for _ in range(n)]
    
    for length in range(1, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            substr = s[i:j + 1]
            
            # Try no encoding
            dp[i][j] = substr
            
            # Try encoding as k[pattern]
            for k in range(1, length):
                if length % k == 0:
                    pattern = substr[:k]
                    if pattern * (length // k) == substr:
                        encoded = f"{length // k}[{dp[i][i + k - 1]}]"
                        if len(encoded) < len(dp[i][j]):
                            dp[i][j] = encoded
            
            # Try splitting
            for k in range(i, j):
                split = dp[i][k] + dp[k + 1][j]
                if len(split) < len(dp[i][j]):
                    dp[i][j] = split
    
    return dp[0][n - 1]
\end{lstlisting}
\textbf{Complexity:} Time $O(n^3)$, Space $O(n^2)$

\section{Concatenated Words}
\subsection*{Problem Description}
Find words that are concatenation of shorter words in list.

\subsection*{Solution Approach}
\begin{itemize}
    \item Sort words by length.
    \item Use dynamic programming or DFS.
    \item Check if word can be formed from shorter words.
    \item Use Trie or set for efficient lookup.
\end{itemize}

\subsection*{Key Algorithms}
Dynamic Programming, Trie

\subsection*{Edge Cases}
Empty strings, single character words, no concatenations.

\begin{lstlisting}[language=Python]
def findAllConcatenatedWordsInADict(words: List[str]) -> List[str]:
    word_set = set(words)
    result = []
    
    def can_form(word: str, start: int, count: int) -> bool:
        if start == len(word):
            return count > 1
        
        for end in range(start + 1, len(word) + 1):
            if word[start:end] in word_set:
                if can_form(word, end, count + 1):
                    return True
        
        return False
    
    for word in words:
        if can_form(word, 0, 0):
            result.append(word)
    
    return result
\end{lstlisting}
\textbf{Complexity:} Time $O(n \times m^3)$ where m = max word length, Space $O(n)$

\section{Largest Palindrome Product}
\subsection*{Problem Description}
Largest palindrome made from product of two `n`-digit numbers.

\subsection*{Solution Approach}
\begin{itemize}
    \item Start from largest possible palindrome.
    \item Check if can be factored into two `n`-digit numbers.
    \item Build palindrome from first half.
    \item Special case for `n = 1`.
\end{itemize}

\subsection*{Key Algorithms}
Math, Palindrome Construction

\subsection*{Edge Cases}
`n = 1`, no valid palindrome (impossible here).

\begin{lstlisting}[language=Python]
def largestPalindrome(n: int) -> int:
    if n == 1:
        return 9
    
    upper = 10**n - 1
    lower = 10**(n - 1)
    
    # Try palindromes in decreasing order
    for i in range(upper, lower - 1, -1):
        # Build palindrome
        palindrome = int(str(i) + str(i)[::-1])
        
        # Check if can be factored
        j = upper
        while j * j >= palindrome:
            if palindrome % j == 0 and palindrome // j <= upper:
                return palindrome % 1337
            j -= 1
    
    return -1
\end{lstlisting}
\textbf{Complexity:} Time $O(10^n)$, Space $O(1)$

\section{Sliding Window Median}
\subsection*{Problem Description}
Find median of each window of size `k`.

\subsection*{Solution Approach}
\begin{itemize}
    \item Use two heaps (like median stream).
    \item Handle window sliding with removal.
    \item Use multiset or heap with lazy deletion.
    \item Balance heaps after each operation.
\end{itemize}

\subsection*{Key Algorithms}
Two Heaps, Sliding Window

\subsection*{Edge Cases}
`k = 1`, even/odd `k`, duplicates.

\begin{lstlisting}[language=Python]
from sortedcontainers import SortedList

def medianSlidingWindow(nums: List[int], k: int) -> List[float]:
    window = SortedList()
    result = []
    
    for i, num in enumerate(nums):
        # Add to window
        window.add(num)
        
        # Remove element outside window
        if i >= k:
            window.remove(nums[i - k])
        
        # Calculate median when window is full
        if i >= k - 1:
            if k % 2 == 1:
                result.append(float(window[k // 2]))
            else:
                result.append((window[k // 2 - 1] + window[k // 2]) / 2)
    
    return result
\end{lstlisting}
\textbf{Complexity:} Time $O(n \log k)$, Space $O(k)$

\section{Smallest Good Base}
\subsection*{Problem Description}
Find smallest base where `n` is all 1s in that base.

\subsection*{Solution Approach}
\begin{itemize}
     \item For \texttt{m} digits of 1s: $n = 1 + k + k^2 + \dots + k^{m-1}$.
    \item Try different values of `m` (digits).
    \item Binary search for base `k`.
    \item Check if forms valid representation.
\end{itemize}

\subsection*{Key Algorithms}
Binary Search, Math

\subsection*{Edge Cases}
`n = 3` (base 2), prime numbers.

\begin{lstlisting}[language=Python]
def smallestGoodBase(n: str) -> str:
    n = int(n)
    
    # Try different lengths of 1s
    for m in range(64, 1, -1):
        # Binary search for base
        left, right = 2, int(n**(1/(m-1))) + 1
        
        while left < right:
            mid = (left + right) // 2
            
            # Calculate sum of geometric series
            sum_val = 0
            for i in range(m):
                sum_val = sum_val * mid + 1
                if sum_val > n:
                    break
            
            if sum_val == n:
                return str(mid)
            elif sum_val < n:
                left = mid + 1
            else:
                right = mid
    
    return str(n - 1)
\end{lstlisting}
\textbf{Complexity:} Time $O(\log^2 n)$, Space $O(1)$

\section{Zuma Game}
\subsection*{Problem Description}
Minimum balls to remove all balls by matching 3+ consecutive.

\subsection*{Solution Approach}
\begin{itemize}
    \item Use backtracking with memoization.
    \item Try inserting each ball at each position.
    \item Remove consecutive groups of 3+.
    \item Prune impossible states.
\end{itemize}

\subsection*{Key Algorithms}
Backtracking, String Manipulation

\subsection*{Edge Cases}
Already removable, impossible to clear.

\begin{lstlisting}[language=Python]
from functools import lru_cache
from collections import Counter

def findMinStep(board: str, hand: str) -> int:
    def remove_consecutive(s: str) -> str:
        i = 0
        while i < len(s):
            j = i
            while j < len(s) and s[j] == s[i]:
                j += 1
            if j - i >= 3:
                return remove_consecutive(s[:i] + s[j:])
            i = j
        return s
    
    @lru_cache(None)
    def dfs(board: str, hand: tuple) -> int:
        board = remove_consecutive(board)
        if not board:
            return 0
        if not hand:
            return float('inf')
        
        hand_count = Counter(hand)
        min_balls = float('inf')
        
        for i in range(len(board) + 1):
            for color in hand_count:
                if hand_count[color] > 0:
                    # Try inserting ball at position i
                    new_board = board[:i] + color + board[i:]
                    new_hand = list(hand)
                    new_hand.remove(color)
                    
                    result = 1 + dfs(new_board, tuple(new_hand))
                    min_balls = min(min_balls, result)
        
        return min_balls
    
    result = dfs(board, tuple(hand))
    return result if result != float('inf') else -1
\end{lstlisting}
\textbf{Complexity:} Time $O((m+n)^m \times n!)$ where m = board length, n = hand size, Space $O(mn)$

\section{Robot Room Cleaner}
\subsection*{Problem Description}
Clean entire room with robot using only relative movement.

\subsection*{Solution Approach}
\begin{itemize}
    \item DFS with backtracking.
    \item Track visited cells relative to start.
    \item Try all 4 directions.
    \item Return to original position/direction.
\end{itemize}

\subsection*{Key Algorithms}
DFS, Backtracking

\subsection*{Edge Cases}
Single cell, complex obstacles.

\begin{lstlisting}[language=Python]
class Solution:
    def cleanRoom(self, robot):
        visited = set()
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up
        
        def go_back():
            robot.turnRight()
            robot.turnRight()
            robot.move()
            robot.turnRight()
            robot.turnRight()
        
        def dfs(x: int, y: int, direction: int) -> None:
            visited.add((x, y))
            robot.clean()
            
            # Try all 4 directions
            for i in range(4):
                new_direction = (direction + i) % 4
                dx, dy = directions[new_direction]
                nx, ny = x + dx, y + dy
                
                if (nx, ny) not in visited and robot.move():
                    dfs(nx, ny, new_direction)
                    go_back()
                
                robot.turnRight()
        
        dfs(0, 0, 0)
\end{lstlisting}
\textbf{Complexity:} Time $O(n)$ where n = accessible cells, Space $O(n)$

\section{Reverse Pairs}
\subsection*{Problem Description}
Count pairs where `i < j` and `nums[i] > 2 * nums[j]`.

\subsection*{Solution Approach}
\begin{itemize}
    \item Modified merge sort.
    \item Count during merge process.
    \item Similar to count inversions.
    \item Handle overflow with long comparison.
\end{itemize}

\subsection*{Key Algorithms}
Merge Sort, Divide and Conquer

\subsection*{Edge Cases}
No reverse pairs, all same values, overflow.

\begin{lstlisting}[language=Python]
def reversePairs(nums: List[int]) -> int:
    def merge_sort(start: int, end: int) -> int:
        if end - start <= 1:
            return 0
        
        mid = (start + end) // 2
        count = merge_sort(start, mid) + merge_sort(mid, end)
        
        # Count reverse pairs
        j = mid
        for i in range(start, mid):
            while j < end and nums[i] > 2 * nums[j]:
                j += 1
            count += j - mid
        
        # Merge sorted halves
        temp = []
        i, j = start, mid
        while i < mid and j < end:
            if nums[i] <= nums[j]:
                temp.append(nums[i])
                i += 1
            else:
                temp.append(nums[j])
                j += 1
        
        temp.extend(nums[i:mid])
        temp.extend(nums[j:end])
        nums[start:end] = temp
        
        return count
    
    return merge_sort(0, len(nums))
\end{lstlisting}
\textbf{Complexity:} Time $O(n \log n)$, Space $O(n)$

\section{The Maze III}
\subsection*{Problem Description}
Find path to hole with shortest distance and lexicographically smallest.

\subsection*{Solution Approach}
\begin{itemize}
    \item BFS/Dijkstra with priority queue.
    \item Priority: distance, then path string.
    \item Roll ball until wall or hole.
    \item Track visited with direction.
\end{itemize}

\subsection*{Key Algorithms}
Dijkstra's Algorithm, BFS

\subsection*{Edge Cases}
Ball starts at hole, no path, multiple shortest paths.

\begin{lstlisting}[language=Python]
import heapq

def findShortestWay(maze: List[List[int]], ball: List[int], hole: List[int]) -> str:
    m, n = len(maze), len(maze[0])
    directions = [(1, 0, 'd'), (0, -1, 'l'), (0, 1, 'r'), (-1, 0, 'u')]
    
    # Priority queue: (distance, path, x, y)
    heap = [(0, '', ball[0], ball[1])]
    visited = set()
    
    while heap:
        dist, path, x, y = heapq.heappop(heap)
        
        if (x, y) in visited:
            continue
        visited.add((x, y))
        
        if [x, y] == hole:
            return path
        
        for dx, dy, direction in directions:
            nx, ny, steps = x, y, 0
            
            # Roll until wall or hole
            while 0 <= nx + dx < m and 0 <= ny + dy < n and maze[nx + dx][ny + dy] == 0:
                nx += dx
                ny += dy
                steps += 1
                if [nx, ny] == hole:
                    break
            
            if (nx, ny) not in visited:
                heapq.heappush(heap, (dist + steps, path + direction, nx, ny))
    
    return "impossible"
\end{lstlisting}
\textbf{Complexity:} Time $O(mn \times \max(m,n))$, Space $O(mn)$

\section{IPO}
\subsection*{Problem Description}
Maximize capital by selecting `k` projects with limited initial capital.

\subsection*{Solution Approach}
\begin{itemize}
    \item Sort projects by capital requirement.
    \item Use max heap for available projects' profits.
    \item Greedily select highest profit available.
    \item Update available projects after each selection.
\end{itemize}

\subsection*{Key Algorithms}
Two Heaps, Greedy

\subsection*{Edge Cases}
`k >` number of projects, insufficient capital.

\begin{lstlisting}[language=Python]
import heapq

def findMaximizedCapital(k: int, w: int, profits: List[int], capital: List[int]) -> int:
    # Projects sorted by capital requirement
    projects = sorted(zip(capital, profits))
    
    # Max heap for available projects' profits
    available = []
    i = 0
    
    for _ in range(k):
        # Add all newly available projects
        while i < len(projects) and projects[i][0] <= w:
            heapq.heappush(available, -projects[i][1])
            i += 1
        
        if not available:
            break
        
        # Select project with maximum profit
        w += -heapq.heappop(available)
    
    return w
\end{lstlisting}
\textbf{Complexity:} Time $O(n \log n)$, Space $O(n)$

\section{Freedom Trail}
\subsection*{Problem Description}
Minimum steps to spell key by rotating ring.

\subsection*{Solution Approach}
\begin{itemize}
    \item Dynamic programming with states \texttt{(ring\_pos, key\_index)}.
    \item For each character, try all matching positions.
    \item Calculate rotation distance (clockwise vs counter).
    \item Add 1 for button press.
\end{itemize}

\subsection*{Key Algorithms}
Dynamic Programming

\subsection*{Edge Cases}
Single character, key longer than ring.

\begin{lstlisting}[language=Python]
from functools import lru_cache

def findRotateSteps(ring: str, key: str) -> int:
    n = len(ring)
    
    # Precompute character positions
    char_positions = defaultdict(list)
    for i, char in enumerate(ring):
        char_positions[char].append(i)
    
    @lru_cache(None)
    def dp(ring_pos: int, key_idx: int) -> int:
        if key_idx == len(key):
            return 0
        
        min_steps = float('inf')
        
        for next_pos in char_positions[key[key_idx]]:
            # Calculate rotation distance
            dist = abs(ring_pos - next_pos)
            dist = min(dist, n - dist)
            
            # 1 for button press + rotation + remaining
            steps = 1 + dist + dp(next_pos, key_idx + 1)
            min_steps = min(min_steps, steps)
        
        return min_steps
    
    return dp(0, 0)
\end{lstlisting}
\textbf{Complexity:} Time $O(n^2 \times m)$ where m = key length, Space $O(nm)$

\section{Super Washing Machines}
\subsection*{Problem Description}
Minimum moves to redistribute dresses evenly among machines.

\subsection*{Solution Approach}
\begin{itemize}
    \item Check if total divisible by `n`.
    \item Calculate required flow through each position.
    \item Maximum of: max give away, max absolute flow.
    \item Can't split dress, so some positions bottleneck.
\end{itemize}

\subsection*{Key Algorithms}
Math, Prefix Sum

\subsection*{Edge Cases}
Already balanced, impossible to balance.

\begin{lstlisting}[language=Python]
def findMinMoves(machines: List[int]) -> int:
    total = sum(machines)
    n = len(machines)
    
    if total % n != 0:
        return -1
    
    target = total // n
    moves = 0
    balance = 0
    
    for dresses in machines:
        balance += dresses - target
        # Max between: current imbalance, dresses to give away
        moves = max(moves, abs(balance), dresses - target)
    
    return moves
\end{lstlisting}
\textbf{Complexity:} Time $O(n)$, Space $O(1)$

\section{Word Abbreviation}
\subsection*{Problem Description}
Abbreviate words uniquely with shortest abbreviations.

\subsection*{Solution Approach}
\begin{itemize}
    \item Start with shortest abbreviation for each word.
    \item Resolve conflicts by increasing prefix length.
    \item Group by abbreviation and resolve duplicates.
    \item Ensure abbreviation is shorter than original.
\end{itemize}

\subsection*{Key Algorithms}
Hash Map, String Manipulation

\subsection*{Edge Cases}
No abbreviation shorter, unique prefixes needed.

\begin{lstlisting}[language=Python]
def wordsAbbreviation(words: List[str]) -> List[str]:
    def abbrev(word: str, prefix_len: int) -> str:
        if len(word) - prefix_len <= 2:
            return word
        return word[:prefix_len + 1] + str(len(word) - prefix_len - 2) + word[-1]
    
    n = len(words)
    result = ['' ] * n
    prefix_len = [0] * n
    
    for i in range(n):
        result[i] = abbrev(words[i], 0)
    
    # Resolve conflicts
    duplicates = True
    while duplicates:
        duplicates = False
        groups = defaultdict(list)
        
        for i in range(n):
            groups[result[i]].append(i)
        
        for indices in groups.values():
            if len(indices) > 1:
                duplicates = True
                for i in indices:
                    prefix_len[i] += 1
                    result[i] = abbrev(words[i], prefix_len[i])
    
    return result
\end{lstlisting}
\textbf{Complexity:} Time $O(n^2 \times L)$ worst case where L = max length, Space $O(n)$

\section{Remove Boxes}
\subsection*{Problem Description}
Maximum points removing continuous boxes of same color.

\subsection*{Solution Approach}
\begin{itemize}
    \item 3D DP: \texttt{dp[l][r][k]} = max points removing \texttt{boxes[l:r+1]} with \texttt{k} same-colored boxes to right of \texttt{r}.
    \item Try removing \texttt{boxes[r]} with \texttt{k} boxes.
    \item Try merging with same color in middle.
    \item Memoization for efficiency.
\end{itemize}

\subsection*{Key Algorithms}
Dynamic Programming, Interval DP

\subsection*{Edge Cases}
All same color, alternating colors.

\begin{lstlisting}[language=Python]
from functools import lru_cache

def removeBoxes(boxes: List[int]) -> int:
    @lru_cache(None)
    def dp(l: int, r: int, k: int) -> int:
        if l > r:
            return 0
        
        # Optimization: combine consecutive same colors
        while l < r and boxes[r] == boxes[r - 1]:
            r -= 1
            k += 1
        
        # Option 1: Remove boxes[r] with k boxes
        result = dp(l, r - 1, 0) + (k + 1) ** 2
        
        # Option 2: Find same color in [l, r-1] and merge
        for i in range(l, r):
            if boxes[i] == boxes[r]:
                result = max(result, dp(l, i, k + 1) + dp(i + 1, r - 1, 0))
        
        return result
    
    return dp(0, len(boxes) - 1, 0)
\end{lstlisting}
\textbf{Complexity:} Time $O(n^4)$, Space $O(n^3)$

\section{Split Array with Equal Sum}
\subsection*{Problem Description}
Find if array can be split at `i,j,k` where 4 subarrays have equal sum.

\subsection*{Solution Approach}
\begin{itemize}
    \item Fix middle point `j`.
    \item Find all valid `i` on left with equal sums.
    \item Find all valid `k` on right with equal sums.
    \item Check if any sum appears on both sides.
\end{itemize}

\subsection*{Key Algorithms}
Hash Set, Prefix Sum

\subsection*{Edge Cases}
Array too short, negative numbers.

\begin{lstlisting}[language=Python]
def splitArray(nums: List[int]) -> bool:
    n = len(nums)
    if n < 7:
        return False
    
    # Compute prefix sums
    prefix = [0]
    for num in nums:
        prefix.append(prefix[-1] + num)
    
    # Try each j (middle split)
    for j in range(3, n - 3):
        left_sums = set()
        
        # Find valid i values on left
        for i in range(1, j - 1):
            sum1 = prefix[i]
            sum2 = prefix[j] - prefix[i + 1]
            if sum1 == sum2:
                left_sums.add(sum1)
        
        # Find valid k values on right
        for k in range(j + 2, n - 1):
            sum3 = prefix[k] - prefix[j + 1]
            sum4 = prefix[n] - prefix[k + 1]
            if sum3 == sum4 and sum3 in left_sums:
                return True
    
    return False
\end{lstlisting}
\textbf{Complexity:} Time $O(n^2)$, Space $O(n)$

\section{Student Attendance Record II}
\subsection*{Problem Description}
Count valid attendance records with at most 1 'A' and 2 consecutive 'L'.

\subsection*{Solution Approach}
\begin{itemize}
    \item Dynamic programming with states.
    \item Track: position, number of 'A's, consecutive 'L's.
    \item Three choices at each position: 'P', 'A', 'L'.
    \item Use modulo for large numbers.
\end{itemize}

\subsection*{Key Algorithms}
Dynamic Programming

\subsection*{Edge Cases}
`n = 1`, very large `n`.

\begin{lstlisting}[language=Python]
def checkRecord(n: int) -> int:
    MOD = 10**9 + 7
    
    # dp[i][j][k] = count of valid records of length i with j 'A's and ending with k consecutive 'L's
    # Space optimization: only need previous state
    prev = [[0] * 3 for _ in range(2)]
    prev[0][0] = 1
    
    for i in range(n):
        curr = [[0] * 3 for _ in range(2)]
        
        for j in range(2):  # Number of 'A's
            for k in range(3):  # Consecutive 'L's at end
                # Add 'P'
                curr[j][0] = (curr[j][0] + prev[j][k]) % MOD
                
                # Add 'A'
                if j < 1:
                    curr[j + 1][0] = (curr[j + 1][0] + prev[j][k]) % MOD
                
                # Add 'L'
                if k < 2:
                    curr[j][k + 1] = (curr[j][k + 1] + prev[j][k]) % MOD
        
        prev = curr
    
    # Sum all valid states
    result = 0
    for j in range(2):
        for k in range(3):
            result = (result + prev[j][k]) % MOD
    
    return result
\end{lstlisting}
\textbf{Complexity:} Time $O(n)$, Space $O(1)$

\section{Find the Closest Palindrome}
\subsection*{Problem Description}
Find closest palindrome number (not equal to `n`).

\subsection*{Solution Approach}
\begin{itemize}
    \item Consider special cases: `999...9`, `100...01`.
    \item Get palindrome by mirroring first half.
    \item Try increment/decrement middle digit(s).
    \item Compare all candidates.
\end{itemize}

\subsection*{Key Algorithms}
String Manipulation, Math

\subsection*{Edge Cases}
Single digit, all 9s, `10...01`.

\begin{lstlisting}[language=Python]
def nearestPalindromic(n: str) -> str:
    length = len(n)
    num = int(n)
    
    # Special cases
    candidates = []
    candidates.append(10**length + 1)  # 100...001
    candidates.append(10**(length - 1) - 1)  # 999...999
    
    # Get prefix (first half)
    is_odd = length % 2
    mid = length // 2
    prefix = int(n[:mid + is_odd])
    
    # Generate palindromes by changing middle digit(s)
    for delta in [-1, 0, 1]:
        new_prefix = prefix + delta
        palin = str(new_prefix)
        
        if is_odd:
            palin = palin + palin[-2::-1]
        else:
            palin = palin + palin[::-1]
        
        candidates.append(int(palin))
    
    # Find closest different from n
    min_diff = float('inf')
    result = 0
    
    for cand in candidates:
        if cand != num:
            diff = abs(cand - num)
            if diff < min_diff or (diff == min_diff and cand < result):
                min_diff = diff
                result = cand
    
    return str(result)
\end{lstlisting}
\textbf{Complexity:} Time $O(1)$, Space $O(1)$

\section{Maximum Vacation Days}
\subsection*{Problem Description}
Maximize vacation days with flight constraints.

\subsection*{Solution Approach}
\begin{itemize}
    \item Dynamic programming: \texttt{dp[week][city]} = max days.
    \item For each week, try all reachable cities.
    \item Add vacation days for that city/week.
    \item Handle flight connectivity.
\end{itemize}

\subsection*{Key Algorithms}
Dynamic Programming

\subsection*{Edge Cases}
No flights, single city, all flights available.

\begin{lstlisting}[language=Python]
def maxVacationDays(flights: List[List[int]], days: List[List[int]]) -> int:
    n = len(flights)  # Number of cities
    k = len(days[0])  # Number of weeks
    
    # dp[city] = max vacation days ending at city
    dp = [-1] * n
    dp[0] = 0  # Start at city 0
    
    for week in range(k):
        new_dp = [-1] * n
        
        for dest in range(n):
            for src in range(n):
                # Can stay or fly from src to dest
                if dp[src] != -1 and (src == dest or flights[src][dest]):
                    new_dp[dest] = max(new_dp[dest], dp[src] + days[dest][week])
        
        dp = new_dp
    
    return max(dp)
\end{lstlisting}
\textbf{Complexity:} Time $O(n^2 \times k)$, Space $O(n)$

\section{Find Median Given Frequency of Numbers}
\subsection*{Problem Description}
Find median from numbers table with frequencies.

\subsection*{Solution Approach}
\begin{itemize}
    \item Calculate total count and median position.
    \item Use cumulative sum with window function.
    \item Find number where cumulative sum crosses median position.
    \item Handle even count (average of two middle values).
\end{itemize}

\subsection*{Key SQL}
Window Functions, Cumulative Sum

\subsection*{Edge Cases}
Even/odd total count, single number.

\begin{lstlisting}[language=SQL]
WITH cumulative AS (
    SELECT 
        number,
        frequency,
        SUM(frequency) OVER (ORDER BY number) AS cum_sum,
        SUM(frequency) OVER (ORDER BY number) - frequency AS prev_cum_sum
    FROM Numbers
),
total AS (
    SELECT SUM(frequency) AS total_count
    FROM Numbers
)
SELECT
    AVG(number) AS median
FROM cumulative, total
WHERE 
    (total_count % 2 = 1 AND prev_cum_sum < (total_count + 1) / 2 AND cum_sum >= (total_count + 1) / 2)
    OR 
    (total_count % 2 = 0 AND (prev_cum_sum < total_count / 2 AND cum_sum >= total_count / 2)
                          OR (prev_cum_sum < total_count / 2 + 1 AND cum_sum >= total_count / 2 + 1))
\end{lstlisting}
\textbf{Complexity:} Time $O(n \log n)$, Space $O(n)$

\end{document}
